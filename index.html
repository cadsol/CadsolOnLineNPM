<!DOCTYPE html>
<html lang="en">


<head>
	<meta charset="UTF-8">
	<title>CadsolOnLine 3D NPM</title>
	<link rel="icon" type="image/x-icon" href="./favicon.ico">
	
	<meta name="viewport" content="width=device-width,   initial-scale=1.0">

	<!--  FICHIER CSS----------------------------------------user-scalable=no,minimum-scale=1.0, maximum-scale=1.0,------------------------------------------------------------------ -->
	<link type="text/css" rel="stylesheet" href="./main030624.css">
	<!--  FICHIER CSS----------------------------------------------------------------------------------------------------------- -->
	<style id="styleoverrides" media="screen"></style>
</head>


<body>npm
	<div id="container">
		<div id="info">
			<h1>CadSolOnLine</h1>
			<div id="ver">" " </div>
			<!-- Calculation of sundials on line</br> -->
			by JL.Astre and Y.Massé<br>
			Help: <a href="https://cadsolonline.web-pages.fr" target="_blank" rel="noopener">cadsolonline.web-pages.fr
			</a> <br>
			Library 3D: <a href="https://threejs.org" target="_blank" rel="noopener">Three.js</a> <br>
			Astronomical library:
			<a href="https://en.wikipedia.org/wiki/Jean_Meeus" target="_blank" rel="noopener">Jean Meeus & </a>
			<a href="https://en.wikipedia.org/wiki/Sonia_Keys" target="_blank" rel="noopener">Sonia Keys</a> <br>
			Polyhedra database: <a href="https://home.adelphi.edu/~stemkoski" target="_blank" rel="noopener">
				Lee Stemkoski</a> <br>
			<p>
				<img src="./images/imageMoret.jpg" alt="Image" style="max-width:100%;height:auto">
			</p>
			<label class="open" for="jsoninput"> > Open the Sundial (json format)...</label>
			</br></br></br>
			<div id="menu"> </div>

			<input type="file" id="jsoninput" accept=".json">

		</div>

		<div id="time"> </div>
		<div id="heureDate"> </div>

	</div>

	<script>
		const docinputjson = document.getElementById('jsoninput');
		docinputjson.style.opacity = 0;
	</script>

	<script type="importmap">
		{
			"imports": {
				"three": "./node_modules/three/build/three.module.min.js",
				"three/addons/": "./node_modules/three/examples/jsm/",
				"astronomia/": "./node_modules/astronomia/src/"
			}
		}
	</script>

	<script  src="./parser.js"></script>


	<script type="module">
		//import  {Parser}  from './parser.js';
		import * as EQTIME from 'astronomia/eqtime.js';
		import * as JULIAN from 'astronomia/julian.js';
		import * as base from 'astronomia/base.js';
		import * as SEXA from 'astronomia/sexagesimal.js';
		import { apparentEquatorial } from 'astronomia/solar.js';

		import * as THREE from 'three';

		import Stats from 'three/addons/libs/stats.module.js';
		import { GUI } from './node_modules/lil-gui/dist/lil-gui.esm.min.js'
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

		import { FontLoader } from 'three/addons/loaders/FontLoader.js';
		import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
		import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

		import { PLYExporter } from 'three/addons/exporters/PLYExporter.js';
		import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';
		import { STLExporter } from 'three/addons/exporters/STLExporter.js';
		import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js'

		import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
		import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

		import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';
		import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';


		// -----------------------------------Modules---------------------------------------------------------------------------------------
		import { SP, BF, BFG, ANL, RTS, STP, cs, TableSol, Dst, oe, RechercheParAdresse, getLocation, HTLM, Ephemerid } from './Modcolvars.js';
		import { eclair, Rot, EtoC, ddrte, segm } from './ModAnalem.js'
		import { POLYHEDRA } from './ModPolyhedra.js';

		// -----------------------------------Modules---------------------------------------------------------------------------------------

		document.addEventListener("readystatechange", function (evt) { console.log(document.readyState) })

		document.getElementById("jsoninput").addEventListener('change', function () { loadJsonFile() });

		const
			HS = "solar",
			HLSA = "legal (summer autumn)", HLWS = "legal (winter spring)",
			HA = "Antique",
			HB = 'babylonic', HI = "italic",
			HSDSA = "Sidereal (summer, autumn)", HSDWS = "Sidereal (winter, spring)",
			HPSA = "Planetary (summer, autumn)", HPWS = "Planetary (winter, spring)";


		cs.version = "2025-03-21"
		console.log('THREE.REVISION :  ', THREE.REVISION)

		// const cso = JSON.parse(JSON.stringify(cs))
		// console.log(cso)
		// for (let k in cso) { cs[k] = structuredClone(cso[k]) }
		// console.log(cs)


		let dateJour = new Date()
		//console.log(dateJour.getDate(),dateJour.getMonth())
		let nbJoursAnnee = 365, nbjoursText = "Day (1-365))"
		cs.year = dateJour.getFullYear()
		cs.dayofYear = JULIAN.DayOfYear(cs.year, dateJour.getMonth() + 1, dateJour.getDate(), JULIAN.LeapYearJulian(cs.year))
		if (JULIAN.LeapYearJulian(cs.year)) { nbJoursAnnee = 366; nbjoursText = "Day (1-366))" } else { nbJoursAnnee = 365, nbjoursText = "Day (1-365))" }


		let CSVtext = "", SVGtext = ""  // , CSVephemerid = ""

		let zFuncxy, xFunc, yFunc, zFunc, meshFunction
		let
			uMin = -1, uMax = 1, uRange = uMax - uMin,
			vMin = -1, vMax = 1, vRange = vMax - vMin,
			segments = 50

		let container, stats, buttonNewSundial;
		let camera, renderer, cadran;
		container = document.getElementById('container');

		// camera

		camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 10, 10000);
		camera.position.set(cs.posCamera[0], cs.posCamera[1], cs.posCamera[2]);
		cs.posCamera = camera.position.toArray()
		//console.log(cs.posCamera)

		// scene
		const scene = new THREE.Scene();
		//scene.background= new THREE.Color(cs.background)
		//console.log(localStorage.getItem("BackGround"))
		//scene.background = new THREE.Color(localStorage.getItem("BackGround"))


		const light = new THREE.DirectionalLight(0xffffff, 1);
		light.position.set(0, 1, 1).normalize();
		let lineRay

		const ambientLight = new THREE.AmbientLight(0x505050, 1); // soft white light
		//const ambientLight = new THREE.LightProbe(); 
		scene.add(ambientLight);

		//Set up shadow properties for the light
		light.shadow.mapSize.width = 2048 * 4; // default
		light.shadow.mapSize.height = 2048 * 4; // default
		light.shadow.camera.near = -1000; // default
		light.shadow.camera.far = 1000; // default
		light.shadow.camera.top = 1000;
		light.shadow.camera.bottom = -1000;
		light.shadow.camera.right = 1000;
		light.shadow.camera.left = -1000;


		light.castShadow = true; // default false
		scene.add(light);
		//const helperLight = new THREE.DirectionalLightHelper( light, 100 );
		//scene.add( helperLight );

		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.gammaFactor = 2.2;
		renderer.outputEncoding = THREE.sRGBEncoding;
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		//renderer.outputEncoding = THREE.RGBEncoding;
		renderer.toneMapping = THREE.CineonToneMapping;
		//renderer.toneMapping=THREE.LinearToneMapping
		//renderer.toneMapping=THREE.ReinhardToneMapping
		renderer.shadowMap.enabled = true;
		//THREE.ColorManagement.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
		//renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
		//renderer.shadowMap.type = THREE.PCFShadowMap
		//renderer.localClippingEnabled = true;

		renderer.toneMappingExposure = 1;
		container.appendChild(renderer.domElement);

		// renderer.setPixelRatio( window.devicePixelRatio );
		// renderer.outputEncoding = THREE.sRGBEncoding;

		// stats
		stats = new Stats();
		container.appendChild(stats.dom);

		// OrbitControls
		const controls = new OrbitControls(camera, renderer.domElement);
		controls.minDistance = 70;
		controls.maxDistance = 7000;
		controls.enableDamping = true
		controls.dampingFactor = cs.dampingFactor / 100;

		//addEventListener
		window.addEventListener('resize', onWindowResize);
		//controls.addEventListener('change', render());

		//Button New Sundial
		buttonNewSundial = document.createElement('button');
		buttonNewSundial.innerHTML = 'New Sundial';
		const menu = document.getElementById('menu');
		menu.appendChild(buttonNewSundial);
		const NFexemple = location.hash.substring(1)
		buttonNewSundial.addEventListener("click", function () {
			Info(NFexemple)
			if (NFexemple.length > 0) { NouveauCadran = false } else { NouveauCadran = true }
			run()
		});


		//
		const labeltime = document.getElementById('time');
		labeltime.innerHTML = 'Time';
		// const labeldeceqt = document.getElementById( 'deceqt' );
		// labeldeceqt.innerHTML = 'deceqt';

		const version = document.getElementById('ver');
		version.innerHTML = "Version: " + cs.version

		let cadranSolaireGroup, axeMondeGroup, earthGroup;

		let gnomon, gnomonTore, meshDevise, stylePolaire, sousStylaire, stylePlan, styleBord, BoutStyle, FinStyle,

			styleAnalem, centreAnalem, styleSTP, styleTorique, filHorizontal, filVertical, pilierH1, pilierH2, pilierH3, pilierH4;

		let geometryCircle1STP, circle1STP, geometryCircle2STP, circle2STP
		let geometrySupportSTP, supportSTPsup, supportSTPinf, geometryAxeSTP, axeSTP


		let heuresSolairesGroup, heuresLegalesGroupSA, heuresLegalesGroupWS, heuresAntiquesGroup, arcsDiurnesGroup;
		let heuresBabyloniquesGroup, heuresItaliquesGroup, heuresSDSAgroup, heuresSDWSgroup, groupAxes;
		let heuresHPSAgroup, heuresHPWSgroup;
		let heuresSolairesListeMesh, heuresLegalesListeMeshSA, heuresLegalesListeMeshWS, heuresAntiquesListeMesh,
			heuresBabyloniquesListeMesh,
			heuresItaliquesListeMesh,
			heuresSDSAListeMesh, heuresSDWSListeMesh,
			heuresHPSAListeMesh, heuresHPWSListeMesh,
			arcsDiurnesListeMesh,
			labelAxesListeMesh;

		let analemGroup, analemListeMesh;   // +++
		//let stpGroup, stpListeMesh;   // +++

		let NouveauCadran = false

		cadranSolaireGroup = new THREE.Group();

		heuresSolairesGroup = new THREE.Group();
		heuresLegalesGroupSA = new THREE.Group();
		heuresLegalesGroupWS = new THREE.Group();
		heuresAntiquesGroup = new THREE.Group();
		heuresBabyloniquesGroup = new THREE.Group();
		heuresItaliquesGroup = new THREE.Group();
		heuresSDSAgroup = new THREE.Group();
		heuresSDWSgroup = new THREE.Group();
		heuresHPSAgroup = new THREE.Group();
		heuresHPWSgroup = new THREE.Group();
		arcsDiurnesGroup = new THREE.Group();
		analemGroup = new THREE.Group();///+++
		//stpGroup = new THREE.Group();///+++
		groupAxes = new THREE.Group();
		heuresSolairesListeMesh = [];
		heuresLegalesListeMeshSA = [];
		heuresLegalesListeMeshWS = [];
		heuresAntiquesListeMesh = [];
		heuresBabyloniquesListeMesh = [];
		heuresItaliquesListeMesh = [];
		heuresSDSAListeMesh = [];
		heuresSDWSListeMesh = [];
		heuresHPSAListeMesh = [];
		heuresHPWSListeMesh = [];

		arcsDiurnesListeMesh = [];
		labelAxesListeMesh = [];
		analemListeMesh = [];//+++
		//stpListeMesh = [];//+++

		// Textures
		const textureLoader = new THREE.TextureLoader()

		const textureAcier = new THREE.TextureLoader().load('./images/metaltexture.jpg')
		textureAcier.name = 'steel'
		const textureCuivre = new THREE.TextureLoader().load('./images/metall001-new-tileable.png');
		textureCuivre.name = 'copper'
		const textureFruits = new THREE.TextureLoader().load('./images/fruits.jpg')
		textureFruits.name = 'fruits'
		const textureAsphalt = new THREE.TextureLoader().load('./images/asphalt.jpg')
		textureAsphalt.name = 'asphalt'
		const texturePierreVerte = new THREE.TextureLoader().load('./images/greenStone.jpg');
		texturePierreVerte.name = 'green stone'
		const textureBois = new THREE.TextureLoader().load('./images/hardwood2_diffuse.jpg');
		textureBois.name = 'wood'
		const textureEau = new THREE.TextureLoader().load('./images/waternormals.jpg');
		textureEau.name = 'water'
		var textureCS



		const choixTextures = {
			'none': null, 'steel': textureAcier, 'copper': textureCuivre, 'water': textureEau,
			'asphalt': textureAsphalt, 'wood': textureBois, 'fruits': textureFruits, 'greenstone': texturePierreVerte,
			'file (.JPG, .PNG)': 'JPG-PNG'/*, 'file (.SVG)':'SVG'*/
		}




		const optionsMaterial = { roughness: 0, metalness: 0, transparent: true, opacity: 1,/* side: THREE.DoubleSide,*/ map: null }
		const materialHeuresSolaires = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresLegalesSA = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresLegalesWS = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresAntiques = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresBabyloniques = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresItaliques = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresSDSA = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresSDWS = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresHPSA = new THREE.MeshStandardMaterial(optionsMaterial);
		const materialHeuresHPWS = new THREE.MeshStandardMaterial(optionsMaterial);

		const materialAnalem = new THREE.MeshStandardMaterial(optionsMaterial);// +++

		const materialArcsDiurnes = new THREE.MeshStandardMaterial(optionsMaterial);

		const materialAxeX = new THREE.MeshStandardMaterial({ color: 0xff00ff })
		const materialAxeY = new THREE.MeshStandardMaterial({ color: 0xffff00 })
		const materialAxeZ = new THREE.MeshStandardMaterial({ color: 0x00ffff })


		const materialCS = new THREE.MeshStandardMaterial(
			{ transparent: true, opacity: 1, metalness: 0.5, roughness: 0.5, side: THREE.DoubleSide });



		function lireFichierTexture() {
			const fileInput = document.createElement('input')
			fileInput.type = 'file';
			fileInput.multiple = false;
			fileInput.accept = ".png,.jpg"
			fileInput.addEventListener('change',
				function () {
					const reader = new FileReader();
					const selectedFile = fileInput.files[0]
					const NF = selectedFile.name.toLowerCase()
					reader.readAsDataURL(selectedFile)
					reader.addEventListener("load", () => {
						cs.dataURLtexture = reader.result
						cs.nameTexture = NF
						textureLoader.load(cs.dataURLtexture,
							function (texture) {
								materialCS.map = texture
								materialCS.emissiveMap = texture
								materialCS.needsUpdate = true
							},
							undefined,
							function (err) { console.error('LoadTexture: An error happened.') }
						)
					})

				},
				false);

			document.body.appendChild(fileInput);
			fileInput.click();
		}

		function LireFichierSVG() {
			const fileInput = document.createElement('input')
			fileInput.type = 'file';
			fileInput.multiple = false;
			fileInput.accept = ".svg"
			fileInput.addEventListener('change',
				function () {
					const reader = new FileReader();
					const selectedFile = fileInput.files[0]
					const NF = selectedFile.name.toLowerCase()
					reader.readAsText(selectedFile);
					reader.addEventListener("load", () => {
						cs.dataSVG = reader.result
						cs.nameTexture = NF
						console.log(cs.nameTexture, cs.dataSVG),
							undefined,
							function (err) { console.error('SVG: An error happened.') }
					})
				},
				false);

			document.body.appendChild(fileInput);
			fileInput.click();
		}


		let SVGtextDevise = ""

		//let EffacerLesLignes=true
		// const materialScaphe = new THREE.MeshStandardMaterial(Cercle
		// 	{ transparent: true, opacity: 0.8, roughness: 0.5, map: textureAcier,side:THREE.DoubleSide/*,shadowSide:THREE.BackSide */ });
		// *********************************************************************************************************************************



		function Info(text) {
			document.getElementById("info").innerHTML = "<h3>" + text + "</h3>"
		}



		function CercleSetting(r, h, e, nsteps) {
			const CerclePath = [];
			let a;
			for (let index = 0; index <= nsteps; index++) {
				a = index * Math.PI / nsteps;
				CerclePath.push(new THREE.Vector3(r * Math.cos(a), 0, -r * Math.sin(a)));
			}
			const recShape = new THREE.Shape()
				.moveTo(h, e)
				.lineTo(-h, e)
				.lineTo(-h, -e)
				.lineTo(h, -e)
				.lineTo(h, e)
			const Settings = {
				steps: nsteps,
				bevelEnabled: false,
				extrudePath: new THREE.CatmullRomCurve3(CerclePath, false, 'chordal', 1),
			};
			return { forme: recShape, setting: Settings }
		}
		const Cercle = CercleSetting(0.5, 0.5, 0.025, 180);


		const geometryCSbox = new THREE.BoxGeometry(1, 1, 1);
		const geometryCScyl = new THREE.CylinderGeometry(1, 1, 1, 64, 64);
		const geometryCSsph = new THREE.SphereGeometry(0.5, 64, 64);
		const geometryCScone = new THREE.ConeGeometry(0.5, 1, 64, 64);
		const EquatorialGeometry = new THREE.ExtrudeGeometry(Cercle.forme, Cercle.setting);
		const geometryScaphe = new THREE.SphereGeometry(0.5, 64, 64, Math.PI, Math.PI);

		// ***********************************************************************************************************************************
		const cadranBox = new THREE.Mesh(geometryCSbox, materialCS);
		const cadranCyl = new THREE.Mesh(geometryCScyl, materialCS);
		const cadranSph = new THREE.Mesh(geometryCSsph, materialCS);
		const cadranCone = new THREE.Mesh(geometryCScone, materialCS);
		const cadranEquatorial = new THREE.Mesh(EquatorialGeometry, materialCS);
		const cadranScaphe = new THREE.Mesh(geometryScaphe, materialCS);

		cadran = cadranBox.clone()  //YM: dans MiseEnPlaceCadranEtGnomon(e)

		//SphereGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)


		const materialGnomon = new THREE.MeshStandardMaterial(
			{ transparent: true, opacity: 1, roughness: 0, metalness: 0, side: THREE.DoubleSide, color: 0xffffff, map: textureAcier /*,clippingPlanes:clipPlanes */ });
		const geometryGnomon = new THREE.CylinderGeometry(1, 1, 1, 16);
		gnomon = new THREE.Mesh(geometryGnomon, materialGnomon);

		// Axe de rotation de la terre
		const axeMonde = new THREE.ArrowHelper(
			new THREE.Vector3(0, Math.sin(cs.lati * Math.PI / 180), -Math.cos(cs.lati * Math.PI / 180)),
			new THREE.Vector3(0, 0, 0),
			600,
			0xffff00, 30, 15);


		axeMondeGroup = new THREE.Group();
		axeMondeGroup.add(axeMonde);
		axeMonde.visible = false;

		//const textureLoader = new THREE.TextureLoader();

		const earthGeometry = new THREE.SphereGeometry(1, 32, 32);
		const earthMaterial = new THREE.MeshPhongMaterial({
			specular: 0x333333,
			emissive: "rgb(5,5,5)",
			shininess: 5,
			map: textureLoader.load('./images/earth_pmzp_2048.jpg'),
			specularMap: textureLoader.load('./images/earth_specular_2048.jpg'),
			normalMap: textureLoader.load('./images/earth_normal_2048.jpg'),
			normalScale: new THREE.Vector2(1, 1)
		});
		earthMaterial.tranparent = true;
		earthMaterial.opacity = 0.5;
		const sphereEarth = new THREE.Mesh(earthGeometry, earthMaterial);
		earthGroup = new THREE.Group();
		earthGroup.add(sphereEarth);

		// clouds

		const materialClouds = new THREE.MeshLambertMaterial({
			map: textureLoader.load('./images/earth_clouds_1024.png'),
			//map: textureLoader.load( 'textures/planets/earth_ligths_1024.png' ),
			transparent: true
		});
		const cloudsScale = 1.005
		const meshClouds = new THREE.Mesh(earthGeometry, materialClouds);
		earthGroup.add(meshClouds);

		//sun
		const geometrySun = new THREE.SphereGeometry(15, 32, 16);
		const materialSun = new THREE.MeshPhongMaterial({
			//color: 0xffff00, 
			//specular: 0x333333,
			emissive: "rgb(100,100,5)",
			shininess: 5,
			map: textureLoader.load('./images/sun.jpg')
		});
		const sphereSun = new THREE.Mesh(geometrySun, materialSun);
		axeMondeGroup.add(sphereSun);
		sphereSun.parent = axeMonde;

		//const Dst=1500 // distance terre soleil

		//rayCaster
		let rayCaster = new THREE.Raycaster()
		let rayDirection = new THREE.Vector3();   // direction rayon (vecteur de norme 1)
		let rayOrigin = new THREE.Vector3();    // origine du rayon lumineux virtuel : centre du tore de coord. cs.xgnomon,  cs.ygnomon cs.zgnomon

		const axeTerre = new THREE.ArrowHelper(
			new THREE.Vector3(1, 1, 1),
			new THREE.Vector3(0, 0, 0),
			600,
			0xffffff, 30, 15);
		earthGroup.add(axeTerre);

		scene.background = new THREE.CubeTextureLoader()
		const milkyWaybackGround = new THREE.CubeTextureLoader()
			.setPath('./images/')
			.load([
				'1.jpg',
				'2.jpg',
				'3.jpg',
				'4.jpg',
				'5.jpg',
				'6.jpg'
			]);
		milkyWaybackGround.flipY = true

		// const milkyWaybackGround= new THREE.CubeTextureLoader()
		// 					.setPath( './images/' )
		// 					.load( [
		// 					'px.png',
		// 					'nx.png',
		// 					'py.png',
		// 					'ny.png',
		// 					'pz.png',
		// 					'nz.png'
		// 					] );



		const axeLocalisation = new THREE.ArrowHelper(
			new THREE.Vector3(0, -1, 0),
			new THREE.Vector3(0, 0, 0),
			600,
			0x00ff00, 20, 15);

		const axeX = new THREE.ArrowHelper(
			new THREE.Vector3(1, 0, 0),
			new THREE.Vector3(0, 0, 0),
			800,
			0xff00ff, 20, 5);
		const axeY = new THREE.ArrowHelper(
			new THREE.Vector3(0, 1, 0),
			new THREE.Vector3(0, 0, 0),
			800,
			0xffff00, 20, 5);
		const axeZ = new THREE.ArrowHelper(
			new THREE.Vector3(0, 0, 1),
			new THREE.Vector3(0, 0, 0),
			800,
			0x00ffff, 20, 5);

		// helpers 
		const axesESZHelper = new THREE.AxesHelper(Dst);
		scene.add(axesESZHelper);



		let TS = TableSol(cs.year)
		//  const dd=JULIAN.JDToCalendarGregorian(TS.solJuin)     
		//    console.log((JULIAN.JDToCalendarGregorian(TS.solJuin).month))
		//    console.log(JULIAN.JDToDate(TS.solJuin))
		//    console.log(Math.floor(dd.day)+"/"+dd.month+"/"+dd.day)

		let fontDevise, fontText;
		loadFontDevise();

		//let ligneDate = "";

		const plyloader = new PLYLoader();
		const objloader = new OBJLoader();
		//const gltfloader = new GLTFLoader();

		//let QuaternionTexte = new THREE.Quaternion()

		//let rayOrigin = new THREE.Vector3();    // origine du rayon lumineux virtuel : centre du tore de coord. cs.xgnomon,  cs.ygnomon cs.zgnomon

		//console.log(NFexemple)
		if (NFexemple.length > 0) {
			openSundial(NFexemple)
			buttonNewSundial.innerHTML = NFexemple;
		}

		//document.body.style.cursor = "auto"

		window.addEventListener("keypress", kPress)


		function kPress(evt) {
			if ((evt.ctrlKey) && (evt.keyCode == 10)) { cs.autoCloseMenu = !cs.autoCloseMenu }
		}


		///////////////////////////////////////////////////////////////////////////////////////////////			  

		function openSundial(NFexemple) {
			let csl
			let request = new XMLHttpRequest();

			request.open('GET', './Samples/' + NFexemple);
			request.responseType = 'text';
			request.send();
			request.onload = function () {
				//console.log(request.response);
				cadranSolaireGroup.clear()
				try { csl = JSON.parse(request.response) }
				catch (e) { console.error("Parsing error:", e) }
				//console.log(JSON.stringify(csl,null,2));
				for (var k in csl) { cs[k] = csl[k] }
				//console.log(JSON.stringify(cs,null,2));
				TS = TableSol(cs.year);
				if (JULIAN.LeapYearJulian(cs.year)) { nbJoursAnnee = 366; nbjoursText = "Day (1-366))" }
				else { nbJoursAnnee = 365, nbjoursText = "Day (1-365))" }
				NouveauCadran = false

				// gTypeCadran.hide()
				// gtypeForme.hide()

			};



		}

		//-----------------------------------------------------------------------------------------------------				          
		function run() {
			document.body.style.cursor = "wait"
			init();

			animate();
			document.body.style.cursor = "default"
		}

		function ligneCSVPoly(texte, x0, y0, z0) {
			const v = new THREE.Vector3(x0, y0, z0)
			const s = "  " + cs.separateurCSV + "  "
			const nd = 3
			meshGnomons[nfaceActive].worldToLocal(v)
			const xg = v.x
			const yg = -v.z
			x0 = xg + cs.polyGx[nfaceActive]; y0 = yg + cs.polyGy[nfaceActive]
			CSVtext += texte + s + x0.toFixed(nd) + s + y0.toFixed(nd) + s + "   " + s + "   " + s + xg.toFixed(nd) + s + yg.toFixed(nd) + "\n"
		}

		function ligneCSV(texte, x0, y0, z0) {
			if (RTSpolyhedre()) { ligneCSVPoly(texte, x0, y0, z0); return }
			const s = "  " + cs.separateurCSV + "  "
			const nd = 3
			const xg = x0 - cs.xgnomon
			const yg = y0 - cs.ygnomon

			if (cs.typeCadran == RTS) {
				CSVtext += texte + s + x0.toFixed(nd) + s + y0.toFixed(nd) + s + z0.toFixed(nd) + s + "   " + s + xg.toFixed(nd) + s + yg.toFixed(nd) + "\n"
			} else {
				CSVtext += texte + s + x0.toFixed(nd) + s + y0.toFixed(nd) + s + "   " + s + "   " + s + xg.toFixed(nd) + s + yg.toFixed(nd) + "\n"
			}
		}

		function initCSVtext() {
			let s = cs.separateurCSV
			CSVtext = "CadsolOnLine      " + s + "   XO   " + s + "  YO  " + s + "   ZO   " + s + "       " + s + "  XG  " + s + "  YG   \n\n";
			CSVtext += " Version: " + cs.version + "\n\n"
			CSVtext += " XO YO  ZO  origin : center of the sundial \n"
			CSVtext += " XG YG      origin : foot of the gnomon \n"
			CSVtext += "\n\n";
			CSVtext += "Sundial: " + cs.nameFile
			CSVtext += "\n\n";
			CSVtext += "Type of sundial : " + cs.typeCadran + "\n"
			if (cs.typeCadran == RTS) { CSVtext += "Form  : " + cs.typeForme + "\n" }
			if ((RTSpolyhedre()) && (polyhedre != undefined)) {
				CSVtext += "Polyhedre : " + polyhedre.name + "\n"
				CSVtext += "Facet : " + cs.polyDev[nfaceActive] + "\n"
			}
			CSVtext += "\n\n";

			if (cs.typeCadran == STP) {
				CSVtext = "CadsolOnLine      " //+ s + "   XO   " + s + "  YO  " + s + "   ZO   "  + "  \n\n";
				CSVtext += " Version: " + cs.version + "\n\n"

				CSVtext += "Sundial: " + cs.nameFile
				CSVtext += "\n\n";
				CSVtext += "Type of sundial : " + cs.typeCadran + "\n\n"
			}

		}


		function initSVGtext(unit) {
			//cs.largeur *=Math.PI
			SVGtext =
				`<?xml version="1.0" standalone="no"?>
<svg 
`
			if (unit == "auto") { SVGtext += `width="100%" height="100%"` }
			else { SVGtext += `width="${cs.largeur.toString() + unit}" height="${cs.hauteur.toString() + unit}"` }

			SVGtext += ` viewBox="0 0 ${cs.largeur.toString()} ${cs.hauteur.toString()}" preserveAspectRatio="xMinYMin meet"
  xmlns="http://www.w3.org/2000/svg">

  <desc> 

  CadsolOnLine  ${cs.version}
  
  </desc>

  <rect x="0" y="0" width="${cs.largeur.toString()}" height="${cs.hauteur.toString()}" 
   fill="${cs.colorCS}" stroke="black" stroke-width="1px" />

  <image
    href="${cs.dataURLtexture}"
    x="0"
    y="0"
    height="${cs.hauteur.toString()}" 
    width="${cs.largeur.toString()}" />
 
  
`
			SVGtextDevise = ""
			//cs.largeur /= Math.PI
		}

		function pointSVG(xp, yp) {
			if (SVGtext.length > 0) {
				
				//xp=xp+cs.xgnomon;yp=yp+cs.ygnomon
				// const alpha=Math.atan2(xp-cs.xgnomon,yp-cs.ygnomon)
				// const R=cs.largeur/2 
				// xp=R*alpha 
				//xp=xp-cs.xgnomon;yp=yp-cs.ygnomon
			
				
				const xs = xp + cs.largeur / 2;
				const ys = -yp + cs.hauteur / 2
				SVGtext += `${xs.toFixed(3)},${ys.toFixed(3)}   `
				

			}
		}

		function closeSVGtext() {
			SVGtext += '</svg>';
			// console.log(SVGtext)
		}

		function construireFichierSVG() {

			if (RTSpolyhedre()==false) {
				initSVGtext(cs.unitSVG);
				EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey);
				VoirPoly2D = false
				TracerHeuresEtArcs()
				croixSVG(cs.xgnomon, cs.ygnomon) 
			}

			if (RTSpolyhedre()==true) {
				VoirPoly2D = true
				const sommets = SommetsFace(nfaceActive, polyhedre)
				displayFaces(polyhedre)
				let l = cs.largeur; let h = cs.hauteur; let k = Math.max(cs.largeur, cs.hauteur, cs.epaisseur)
				cs.largeur = 2.5 * k
				cs.hauteur = 2.5 * k
				initSVGtext(cs.unitSVG);
				const ns = sommets.length
				for (let i = 0; i < ns - 1; i++) {
					ligneSVG(sommets[i].x, -sommets[i].z, sommets[i + 1].x, -sommets[i + 1].z)
				}
			
				EcrireDevise(cs.polyDev[nfaceActive], cs.polyDevx[nfaceActive], cs.polyDevy[nfaceActive], nfaceActive)
		
				croixSVG(0, 0)
				TracerHeuresEtArcs()
				cs.largeur = l; cs.hauteur = h
			}
	
			SVGtext += SVGtextDevise
			closeSVGtext();
		}


		//----------------------------------------------------------------------------
		function loadFontDevise() {
			const loader = new FontLoader();
		
			loader.load('./node_modules/three/examples/fonts/optimer_regular.typeface.json',
				function (response) { fontText = response },
				function (xhr) {/*console.log( (xhr.loaded / xhr.total * 100) + '% loaded' )*/ },
				function (err) { console.log('An error fontText happened') }
			);
			loader.load('./node_modules/three/examples/fonts/optimer_regular.typeface.json',
				function (response) { fontDevise = response },
				function (xhr) {/*console.log( (xhr.loaded / xhr.total * 100) + '% loaded' )*/ },
				function (err) { console.log('An error fontDevise happened') }
			);

		}

		// Ecritures------------------------------------------------------------  
		function EcrireDevise(texte, x, y, n = nfaceActive) {
			if ((cs.deviseSize == 0) || (texte == undefined)) return;
			//try{
			//console.log(texte)
			const fontGeometry = new TextGeometry(texte, {
				font: fontDevise,
				size: 10 * cs.deviseSize,             //ajuster sur largeur
				height: 2 * cs.deviseSize,           //ajuster sur largeur
				curveSegments: 4,
				bevelEnabled: true,
				bevelThickness: 0.5 * cs.deviseSize, //ajuster sur largeur
				bevelSize: 0.5 * cs.deviseSize,      //ajuster sur largeur
				bevelOffset: 0,
				bevelSegments: 1,
				depth: 1*cs.egnomon  //bug! 1*cs.egnomon/2 AJL
			})
			// }catch (error) {
			// 		cnsole.log(console.error("Font geometry error:", error))
			// 		return
			// 	}



			if ((cs.typeCadran == RTS) && (cs.typeForme == "polyedric")) {
				//console.log(n)
				if (typeof (meshDevise) !== "undefined") { meshGnomons[n].remove(meshDevise) };
				meshDevise = new THREE.Mesh(fontGeometry, materialGnomon);
				meshGnomons[n].add(meshDevise)
				meshDevise.position.set(x - cs.polyGx[n], -hauteursGnomons[n] / 2, -y + cs.polyGy[n])
				meshDevise.rotateX(-Math.PI / 2)
				//meshDevise.applyQuaternion (meshGnomons[nFace].quaternion);meshDevise.rotateX(-Math.PI / 2)
			} else {
				if (typeof (meshDevise) !== "undefined") { cadranSolaireGroup.remove(meshDevise) };
				meshDevise = new THREE.Mesh(fontGeometry, materialGnomon);
				cadranSolaireGroup.add(meshDevise);
				meshDevise.position.x = x;
				meshDevise.position.y = y;
				meshDevise.position.z = cs.epaisseur / 2
			}


			if (RTSpolyhedre()) {
				x = x - cs.polyGx[n] + cs.largeur / 2; y = -y + cs.polyGy[n] + cs.hauteur / 2;
				SVGtextDevise = `<text x="${x.toString()}" y="${y.toString()}" font-size="${(cs.deviseSize * 10).toString()}" font-family='Courier New'  stroke="black" > ${cs.polyDev[n]}</text>
					 `
			} else {
				x = x + cs.largeur / 2; y = -y + cs.hauteur / 2;
				SVGtextDevise = `<text x="${x.toString()}" y="${y.toString()}" font-size="${(cs.deviseSize * 10).toString()}" font-family='Courier New'  stroke="black" > ${cs.devise}</text>
				`
			}
		}

		function EcrireTexte(texte, x, y, z, material, group, listeMesh, gauche = false, gpos = false, rot = 0) {
			if ((cs.hoursTextSize == 0) || (texte == undefined)) return;

			let mesh
			const fontGeometry = new TextGeometry(texte, {
				font: fontText,
				size: 7* cs.hoursTextSize,             //ajuster sur largeur
				height: 1 * cs.hoursTextSize/10,           //ajuster sur largeur
				curveSegments: 4,
				bevelEnabled: true,
				bevelThickness: 0.25 * cs.hoursTextSize, //ajuster sur largeur
				bevelSize: 0.25 * cs.hoursTextSize,      //ajuster sur largeur
				bevelOffset: 0,
				bevelSegments: 1,
				depth: 1*cs.egnomon
			});

			mesh = new THREE.Mesh(fontGeometry, material);

			if (RTSpolyhedre()) {
				meshGnomons[nfaceActive].add(mesh)
				mesh.applyQuaternion(meshGnomons[nfaceActive].quaternion)
				mesh.rotateX(-Math.PI / 2)
			} else { mesh.rotation.y = rot } // correction AJL

			group.add(mesh);
			listeMesh.push(mesh);
			// if (gauche) { x = x - (texte.length - 1) * 7 * cs.hoursTextSize }//else{x=x+7*cs.hoursTextSize}
			let txtl = texte.length * 5 * cs.hoursTextSize;
			if (gauche) x -= txtl;
			if (gpos) {
				if (x < -cs.largeur / 2) x = -cs.largeur / 2;
				if (y < -cs.hauteur / 2) y = -cs.hauteur / 2;
				// if ((x + 7 * cs.hoursTextSize) > (cs.largeur / 2 - 5)) { x -= 14 * cs.hoursTextSize }
				if (x + txtl > cs.largeur / 2) x = cs.largeur / 2 - txtl;
				// if ((y + 7 * cs.hoursTextSize) > (cs.hauteur / 2 - 5)) { y -= 14 * cs.hoursTextSize }
				if (y + 7 * cs.hoursTextSize > cs.hauteur / 2) y = cs.hauteur / 2 - 7 * cs.hoursTextSize;
			}
			mesh.position.x = x;
			mesh.position.y = y;
			mesh.position.z = z

			if (SVGtext.length > 0) {
				x = x + cs.largeur / 2; y = -y + cs.hauteur / 2;
				//if (gauche) {texte=texte+"  "}else{texte="  "+texte}
				SVGtext += `<text x="${x.toFixed(2)}" y="${y.toFixed(2)}" font-size="${(cs.hoursTextSize * 10).toString()}" font-family="Courier New" stroke="${material.color.getStyle()}" textLength="${txtl.toFixed(2)}"> ${texte}</text>
           `
			}

		}


		//------------------------------------------------------------------------------------------------------------
		function TracerHeuresEtArcs() {
			document.body.style.cursor = 'progress'
			initCSVtext()
			TracerStyle()
			switch (cs.typeCadran) {
				case ANL:
					TracerAnalem();
					break
				case STP:
					TracerSTP();
					break
				default:

					if (cs.heuresSolaires) { TracerHeuresSolaires() }
					if (cs.heuresLegalesWinterSpring) { TracerHeuresLegalesWS() }
					if (cs.heuresLegalesSummerAutums) { TracerHeuresLegalesSA() }
					if (cs.heuresAntiques) { TracerHeuresAntiques() }
					if (cs.heuresBabyloniques) { TracerHeuresBabyloniques() }
					if (cs.heuresItaliques) { TracerHeuresItaliques() }
					if (cs.heuresSideralesSA) { TracerHeuresSDSA() }
					if (cs.heuresSideralesWS) { TracerHeuresSDWS() }
					if (cs.heuresPlanetairesWS) { TracerHeuresHPWS() }
					if (cs.heuresPlanetairesSA) { TracerHeuresHPSA() }

					TracerArcsDiurnes()
			}

			PlacerLeSoleil()

			if (RTSpolyhedre()) { memoriserFace(nfaceActive) }
			document.body.style.cursor = 'default'
		}

		//--------------------------------------------------------------------------------------------------------------

		let xd = 0, yd = 0, zd = 1    // Direction Gnomon analemmatique  Modif AJL 
		function Proj([x, y, z]) {            // Projection sur le cadran avec mise à la dimension R
			x *= cs.Ranalem; y *= cs.Ranalem; z *= cs.Ranalem;
			const bc = cs.Canalem ? 1 : 0;
			const pr = cs.Canalem && (Math.abs(zd) <= Math.sign(zd) * z) ?
				-cs.epaisseur / 2 : cs.epaisseur / 2;
			return new THREE.Vector3((y * zd - z * xd) / (zd - bc * z) + cs.xgnomon, (-x * zd - z * yd) / (zd - bc * z) + cs.ygnomon, pr);
		}


		function TracerAnalem() {
			cs.hoursTextSize = cs.textSizeANL;
			effacelisteMesh(analemListeMesh, analemGroup);
			const gpostxt = true;

			var frh = 1 / cs.subAnalem, cl = 0, fh = 0;
			var al = eclair();	// Angles horaires limites
			var hd = Math.floor(Math.round(2 * frh * (al[0] * 12 / Math.PI + cl * (fh - cs.longi / 15) + 12)) / 2) / frh;
			var h1 = Math.ceil(Math.round(2 * frh * (al[1] * 12 / Math.PI + cl * (fh - cs.longi / 15) + 12)) / 2) / frh;
			var h2 = Math.floor(Math.round(2 * frh * (al[2] * 12 / Math.PI + cl * (fh - cs.longi / 15) + 12)) / 2) / frh;
			var hf = Math.ceil(Math.round(2 * frh * (al[3] * 12 / Math.PI + cl * (fh - cs.longi / 15) + 12)) / 2) / frh;
			if (hf >= hd + 24) hf = hd + 24;

			const ob = .4091;		// Obliquité de l'écliptique
			const nsg = 4;			// Nombre de segment par heure, doit être multiple de 4 
			var x, y, z, dc, ch;

			// Indications 2D et CSV ---------------
			dc = cs.Hanalem * 100 / cs.Ranalem / cs.zdirect;
			x = xd * dc; y = yd * dc; z = zd * dc;
			ch = "  " + cs.separateurCSV + "  ";
			CSVtext += "End of the gnomon placed at X0, Y0, Z0 = 0\n\n";
			CSVtext += "point" + ch + x.toFixed(3) + ch + y.toFixed(3) + ch + z.toFixed(3) + "\n";
			if (cs.Canalem) {
				CSVtext += "\n\nCenter position\n\n";
				CSVtext += "point" + ch + xd.toFixed(3) + ch + yd.toFixed(3) + ch + zd.toFixed(3) + "\n";
			}
			ligneSVG(cs.xgnomon, cs.ygnomon, x + cs.xgnomon, y + cs.ygnomon, 1, "gray");
			x = -cs.largeur / 2 + 5; y = cs.hauteur / 2 - 5;
			dc = cs.Ranalem * cs.zdirect / 100;
			croixSVG(x, y);
			ligneSVG(x, y, x + cs.Hanalem, y);
			if (cs.Canalem) {
				disqueSVG(xd + cs.xgnomon, yd + cs.ygnomon, 3, "gray");
				if (dc >= 0) {
					disqueSVG(x + dc, y, 3, "black");
				} else {
					ligneSVG(cs.xgnomon, cs.ygnomon, xd + cs.xgnomon, yd + cs.ygnomon, 1, "gray", 3);
					y -= 10;
					disqueSVG(x, y, 3, "black");
					ligneSVG(x, y, x - dc, y, 1, "black", 3);
					croixSVG(x - dc, y);
				}
			}
			dc = 180 * Math.atan(Math.abs(zd) / Math.sqrt(xd ** 2 + yd ** 2)) / Math.PI;
			ch = `Angle : ${dc.toFixed(2)}°`;
			y = cs.hauteur / 2 - y + 12;
			if (SVGtext.length > 0) {
				SVGtext += `<text x="5" y="${y}" font-size="10" font-family="Courier New" stroke="black">${ch}</text>
           `;
			}

			// Courbe horaire -------------------------
			CSVtext += "\n\nHour curve\n";
			var pj, pths = [], rt = -1;
			for (let hv = Math.round(hd * nsg); hv <= Math.round(hf * nsg); hv++) {
				if (hv > Math.round(h1 * nsg) && hv < Math.round(h2 * nsg)) {		// Le cadran n'est jamais éclairé.
					if (rt >= 0) { traceAnalem(pths, cs.egnomon, 100); rt = -1; }
				} else {
					[x, y] = Rot(1, 0, 15 * hv / nsg);		// Direction du point horaire dans le repère polaire.
					pj = Proj(EtoC(x, y, 0));
					if (pj.z < 0) {												// La courbe n'est pas utile
						if (rt >= 0) { traceAnalem(pths, cs.egnomon, 100); rt = -1; }
					} else {
						if (rt == -1) {											// Initialisation d'une nouvelle portion de courbe.
							pths.push(pj); rt = 0;
						} else {
							rt = segm(pths, pj);
							if (rt == 2 || rt == 4) {					// Fin de la portion de courbe.
								traceAnalem(pths, cs.egnomon, 100);
								pths.push(pj);									// On peut enchainer avec de nouveaux points.
							}
						}
					}
				}
			}
			traceAnalem(pths, cs.egnomon, 100);

			// Plots horaires -------------------------
			CSVtext += "\n\nHour points\n\n";
			var plotGeo, plotMesh;
			var bh, xh, yh, dx, dy, rc;
			for (let hv = hd; hv <= hf; hv += cs.subAnalem) {
				[x, y] = Rot(1, 0, 15 * hv) // Direction du point horaire dans le repère polaire
				pj = Proj(EtoC(x, y, 0));
				if ((pj.z > 0) && (Math.abs(pj.x) <= cs.largeur / 2) && (Math.abs(pj.y) <= cs.hauteur / 2)
					&& ((hv <= h1) || (hv >= h2))) {
					bh = presqueEntier(hv);
					rc = bh ? 3 * cs.egnomon : 2 * cs.egnomon;
					plotGeo = new THREE.CylinderGeometry(rc, rc, 2 * cs.egnomon,);
					plotMesh = new THREE.Mesh(plotGeo, materialAnalem);
					plotMesh.rotateX(Math.PI / 2);
					plotMesh.position.set(pj.x, pj.y, pj.z);
					analemListeMesh.push(plotMesh);
					analemGroup.add(plotMesh);
					disqueSVG(pj.x, pj.y, rc, cs.colorAnalem);
					ligneCSV(`${hv} H:`, pj.x, pj.y);
					if (bh) {
						xh = pj.x; yh = pj.y;
						dy = xh; dx = yh;
						[x, y] = Rot(1, 0, 15.01 * hv) // Direction du point horaire dans le repère polaire
						pj = Proj(EtoC(x, y, 0));
						dy -= pj.x; dx -= pj.y;
						rc = (3 * cs.egnomon + 5 * cs.hoursTextSize) / Math.sqrt(dx ** 2 + dy ** 2);
						dx *= rc; dy *= rc;
						if (dx * (xh - cs.xgnomon) - dy * (yh - cs.ygnomon) > -0.1) dy = -dy; else dx = -dx;
						dx -= 2.5 * hv.toString().length * cs.hoursTextSize;
						dy -= 3.5 * cs.hoursTextSize;
						EcrireTexte(hv.toString(), xh + dx, yh + dy, pj.z,
							materialAnalem, analemGroup, analemListeMesh, false, gpostxt);
					}
				}
			}

			// Ligne des dates -------------------------
			CSVtext += "\n\nDate line\n";
			pths.push(Proj(EtoC(0, 0, Math.tan(-ob))));
			pj = Proj(EtoC(0, 0, Math.tan(ob)));
			if (pj.z * pths[0].z < 0) {			// Passage à l'infini
				ddrte(pths, pths[0].x - pj.x, pths[0].y - pj.y);
				traceAnalem(pths, cs.egnomon / 2, 10);
				pths.push(pj);
				pj = Proj(EtoC(0, 0, Math.tan(-ob)));
				ddrte(pths, pths[0].x - pj.x, pths[0].y - pj.y);
				traceAnalem(pths, cs.egnomon / 2, 10);
			} else {
				segm(pths, pj);
				traceAnalem(pths, cs.egnomon / 2, 10);
			}

			// Graduation de la ligne des dates -----------------
			EcrirelesDates(gpostxt);

			cadranSolaireGroup.add(analemGroup);
		}

		function traceAnalem(points, eptrait, npoints) {
			// Note : le tableau points est vidé à la fin de la procédure.
			if (points.length > 1) {
				CSVtext += "\n";
				if (SVGtext.length > 0) {
					SVGtext += ` 
		          <polyline fill="none" stroke="${materialAnalem.color.getStyle()}" stroke-width="${eptrait}"
		           points= " `
				}
				for (let p = 0; p < points.length; p++) {
					ligneCSV("point", points[p].x, points[p].y);
					SVGtext += `${(points[p].x + cs.largeur / 2).toFixed(3)},${(-points[p].y + cs.hauteur / 2).toFixed(3)}   `
				}
				SVGtext += `" />`;

				const pipeSplineCRC = new THREE.CatmullRomCurve3(points, false, 'chordal', 1);
				const tubeGeometry = new THREE.TubeGeometry(pipeSplineCRC, npoints, eptrait, npoints, false);
				const mesh = new THREE.Mesh(tubeGeometry, materialAnalem);
				//mesh.receiveShadow = true;
				analemListeMesh.push(mesh);
				analemGroup.add(mesh);
			}
			points.splice(0, points.length);		// Vide le tableau
		}


		const kSTP = 0.475 // 0.475 dans source YM ???
		function TracerSTP() {
			cs.hoursTextSize = cs.textSizeANL;
			cs.incli = cs.lati;
			eulerCsGroup();
			cs.epaisseur = cs.largeur;
			cadran.scale.z = cs.largeur;

			effacelisteMesh(analemListeMesh, analemGroup);

			// Ligne horaire
			const nsteps = 180;
			let a, r = kSTP * cs.largeur, lineH = [];
			for (let index = 0; index <= nsteps; index++) {
				a = index * Math.PI / nsteps;
				lineH.push(new THREE.Vector3(r * Math.cos(a), 0, -r * Math.sin(a)));
			}
			//console.log(lineH)
			const pipeSplineCRC = new THREE.CatmullRomCurve3(lineH, false, 'chordal', 1);
			const tubeGeometry = new THREE.TubeGeometry(pipeSplineCRC, nsteps, cs.egnomon / 2, 16, false);
			const mesh = new THREE.Mesh(tubeGeometry, materialAnalem);
			analemListeMesh.push(mesh); analemGroup.add(mesh);

			// Graduations
			let plotGeo, plotMesh, x, z, rt, bh, rp, hp;
			CSVtext += "\n\n"
			CSVtext += "Graduations\n\n"
			CSVtext += " X  Y  Z  origin : center of the sundial \n"
			CSVtext += "\n\n";
			CSVtext += "Decimal Hour" + cs.separateurCSV + "X" + cs.separateurCSV + "Y" + cs.separateurCSV + "Z" + "\n";
			for (let hl = 4; hl <= 20; hl += cs.subAnalem) {
				rt = cs.a - cs.longi + cs.offset_sec / 240 - 15 * hl;
				[x, z] = Rot(0, kSTP * cs.largeur, rt);
				if (z < 0) {
					bh = presqueEntier(hl);
					rp = (bh ? 2 * cs.egnomon : 0.5 * cs.egnomon);
					hp = (bh ? 10 * cs.egnomon : 5 * cs.egnomon);
					plotGeo = new THREE.CylinderGeometry(rp, rp, hp);
					plotMesh = new THREE.Mesh(plotGeo, materialAnalem);
					plotMesh.position.set(x, 0, z);//console.log(x,z)separateurCSV
					analemListeMesh.push(plotMesh);
					analemGroup.add(plotMesh);
					rp = 2.5 * hl.toString().length * cs.hoursTextSize / kSTP / cs.largeur;
					[x, z] = Rot(x, z, rp * 180 / Math.PI);
					rp += (rt + 180) * Math.PI / 180;
					if (bh) EcrireTexte(hl.toString(), x, 0.8 * hp, z,
						materialAnalem, analemGroup, analemListeMesh, false, false, rp);
					CSVtext += "Hour:" + hl.toFixed(2) + cs.separateurCSV + x.toFixed(3) + cs.separateurCSV + "0" + cs.separateurCSV + z.toFixed(3) + "\n";
				}
			}

			cadranSolaireGroup.add(analemGroup);
		}


		// --------------------------------------------------------------------------------------------------------
		function pointDansCadran(x, y) {
			return (cs.typeCadran == RTS) || ((Math.abs(x) <= (cs.largeur / 2)) && (Math.abs(y) <= (cs.hauteur / 2)))
		}
		//---------------------------------------------------------------------------------------------------------
		let g1, g2, k1, k2;
		function calculg1g2k1k2() {

			const a = cs.hfilHorizontal
			const b = cs.hfilVertical
			const e = b - a
			const [sinj1, cosj1] = base.sincos(base.toRad(cs.anglefilHorizontal))
			const [sinj2, cosj2] = base.sincos(base.toRad(cs.anglefilVertical))
			const sinj1mj2 = Math.sin(base.toRad(cs.anglefilHorizontal - cs.anglefilVertical))
			g1 = (b * sinj2 * cosj1 - a * sinj1 * cosj2) / sinj1mj2
			g2 = (b * sinj1 * cosj2 - a * sinj2 * cosj1) / sinj1mj2
			k1 = e * cosj1 * cosj2 / sinj1mj2
			k2 = e * sinj1 * sinj2 / sinj1mj2
		}

		function disqueSVG(x, y, r, cl) {
			if (SVGtext.length > 0) {
				x += cs.largeur / 2; y = -y + cs.hauteur / 2;
				SVGtext += `<circle cx="${x.toFixed(3)}" cy="${y.toFixed(3)}" r="${r.toFixed(3)}" fill="${cl}" />
				`;
			}
		}

		function ligneSVG(xg, yg, xp, yp, wd = 1, cl = "black", pt = 0) {
			if (SVGtext.length > 0) {
				xg = xg + cs.largeur / 2; yg = -yg + cs.hauteur / 2
				xp = xp + cs.largeur / 2; yp = -yp + cs.hauteur / 2
				let ch = (pt == 0) ? "" : `stroke-dasharray="${pt.toFixed(2)}" `;
				SVGtext += `
			<line x1="${xg.toFixed(3)}" y1="${yg.toFixed(3)}" x2="${xp.toFixed(3)}" y2="${yp.toFixed(3)}"
			stroke="${cl}" stroke-width="${wd.toFixed(2)}" ${ch}/>
			`}
		}

		function croixSVG(x, y) {
			ligneSVG(x - 3, y - 3, x + 3, y + 3)
			ligneSVG(x - 3, y + 3, x + 3, y - 3)
		}


		function EcrirelesDates(gpostxt) {
			let dx, dy, rc, an, pj, j, jde, ae, js, ms, gradGeo, gradMesh, jj, mm;
			CSVtext += "\n\nDate points\n\n";
			pj = Proj(EtoC(0, 0, .01)); dx = pj.x - cs.xgnomon; dy = pj.y - cs.ygnomon;
			rc = Math.sqrt(dx ** 2 + dy ** 2);
			if (rc != 0) {
				if (dy < 0) rc = -rc;
				dx *= cs.egnomon / rc; dy *= cs.egnomon / rc;  // Normalisation
			} else dy = 1;
			rc = 3 * cs.hoursTextSize // pour le décalage de l'écriture
			for (let m = 1; m < 13; m++) {
				j = cs.dateAnalem;
				jde = JULIAN.CalendarGregorianToJD(cs.year, m, j);
				ae = apparentEquatorial(jde);
				pj = Proj(EtoC(0, 0, Math.tan(ae.dec)));
				pj.z = Math.abs(pj.z);
				if ((Math.abs(pj.x) <= (cs.largeur / 2)) && (Math.abs(pj.y) <= (cs.hauteur / 2))) {
					gradGeo = new THREE.CylinderGeometry(cs.egnomon, cs.egnomon, 3 * cs.egnomon);
					gradMesh = new THREE.Mesh(gradGeo, materialAnalem);
					gradMesh.rotateZ(Math.atan2(dy, dx));

					const dateGregorian = JULIAN.JDToCalendarGregorian(jde)  //
					jj = dateGregorian.day; mm = dateGregorian.month             // correction JL pour les mois de 30, 29 ou 28 jpours
					js = jj.toString();                                     //
					ms = mm.toString(); if (mm < 10) { ms = '0' + ms };     //

					if ((jde > TS.solJuin) && (jde < TS.solDecembre)) {  // à gauche
						gradMesh.position.set(pj.x - 2 * dy, pj.y + 2 * dx, pj.z);
						EcrireTexte(js + "/" + ms, pj.x - 5 * dy, pj.y + 5 * dx - rc, pj.z,
							materialAnalem, analemGroup, analemListeMesh, true, gpostxt);
						ligneSVG(pj.x - 4 * dy, pj.y + 4 * dx, pj.x, pj.y, cs.egnomon, cs.colorAnalem);
					} else {
						gradMesh.position.set(pj.x + 2 * dy, pj.y - 2 * dx, pj.z);
						EcrireTexte(js + "/" + ms, pj.x + 5 * dy, pj.y - 5 * dx - rc, pj.z,
							materialAnalem, analemGroup, analemListeMesh, false, gpostxt);
						ligneSVG(pj.x, pj.y, pj.x + 4 * dy, pj.y - 4 * dx, cs.egnomon, cs.colorAnalem);
					}
					ligneCSV(js + "/" + ms + " : ", pj.x, pj.y);
					analemListeMesh.push(gradMesh);
					analemGroup.add(gradMesh);
				}
			}
		}

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		function TracerStyle() {
			let v10, v20, v30, v40, xg, yg, zg, xp, yp, zp, alphaSpSs, x10, y10, x20, y20, h1, h2, OK = true;

			function TracerFil(alpha, hfil1, hfil2) {			//points d'intersection de la droite passant par le pied du style droit, et de coef. dir. tan(alpha)
				let x1, y1, x2, y2, x3, y3, x4, y4				//avec les cotés du cadran rectangulaire -> (x10,y10)   et   (x20,y20)
				let coordFil = [];
				const a = Math.tan(alpha / 180 * Math.PI)
				const b = cs.ygnomon - a * cs.xgnomon
				const h = cs.hauteur / 2; const l = cs.largeur / 2;
				x1 = (h - b) / a; y1 = h; if (pointDansCadran(x1, y1)) { coordFil.push([x1, y1]) }
				x2 = l; y2 = l * a + b; if (pointDansCadran(x2, y2)) { coordFil.push([x2, y2]) }
				x3 = (-h - b) / a; y3 = -h; if (pointDansCadran(x3, y3)) { coordFil.push([x3, y3]) }
				x4 = -l; y4 = (-l) * a + b; if (pointDansCadran(x4, y4)) { coordFil.push([x4, y4]) }
				OK = (coordFil.length == 2)
				if (OK) {
					x10 = coordFil[0][0]; y10 = coordFil[0][1]
					v10 = new THREE.Vector3(x10, y10, (cs.epaisseur / 2 + hfil1))
					x20 = coordFil[1][0]; y20 = coordFil[1][1]
					v20 = new THREE.Vector3(x20, y20, (cs.epaisseur / 2 + hfil2))
				}
				return OK
			}

			if (typeof (FinStyle) !== "undefined") { FinStyle.geometry.dispose() };
			if (typeof (BoutStyle) !== "undefined") { BoutStyle.geometry.dispose() };
			if (typeof (stylePolaire) !== "undefined") { stylePolaire.geometry.dispose() };
			if (typeof (sousStylaire) !== "undefined") { stylePolaire.geometry.dispose() };
			if (typeof (styleAnalem) !== "undefined") { styleAnalem.geometry.dispose() };
			if (typeof (centreAnalem) !== "undefined") { centreAnalem.geometry.dispose() };
			if (typeof (styleSTP) !== "undefined") { styleSTP.geometry.dispose() };
			if (typeof (stylePlan) !== "undefined") { stylePlan.geometry.dispose() };
			if (typeof (styleBord) !== "undefined") { styleBord.geometry.dispose() };
			cadranSolaireGroup.remove(FinStyle);
			cadranSolaireGroup.remove(BoutStyle);
			cadranSolaireGroup.remove(stylePolaire);
			cadranSolaireGroup.remove(sousStylaire);
			cadranSolaireGroup.remove(styleAnalem);
			cadranSolaireGroup.remove(centreAnalem);
			cadranSolaireGroup.remove(styleSTP);
			cadranSolaireGroup.remove(stylePlan);
			cadranSolaireGroup.remove(styleBord);
			if (typeof (filHorizontal) !== "undefined") { filHorizontal.geometry.dispose() };
			if (typeof (filVertical) !== "undefined") { filVertical.geometry.dispose() };
			cadranSolaireGroup.remove(filHorizontal);
			cadranSolaireGroup.remove(filVertical);
			if (typeof (pilierH1) !== "undefined") { pilierH1.geometry.dispose() };
			if (typeof (pilierH2) !== "undefined") { pilierH2.geometry.dispose() };
			if (typeof (pilierH3) !== "undefined") { pilierH3.geometry.dispose() };
			if (typeof (pilierH4) !== "undefined") { pilierH4.geometry.dispose() };
			cadranSolaireGroup.remove(pilierH1);
			cadranSolaireGroup.remove(pilierH2);
			cadranSolaireGroup.remove(pilierH3);
			cadranSolaireGroup.remove(pilierH4);

			if (typeof (styleTorique) !== "undefined") { styleTorique.geometry.dispose() };
			cadranSolaireGroup.remove(styleTorique);

			if (cs.typeCadran == RTS) {

				if (cs.typeForme != "polyedric") {
					const k = Math.max(cs.egnomon, 0.2)
					const geoTore = new THREE.TorusGeometry(k * 5, k, 32, 32)
					styleTorique = new THREE.Mesh(geoTore, materialSun);
					cadranSolaireGroup.add(styleTorique)
					styleTorique.position.set(cs.xgnomon, cs.ygnomon, cs.zgnomon)
					styleTorique.castShadow = true;
					cadran.castShadow = true
				}
			}

			if (cs.typeCadran == SP) {

				xp = cs.xPole + cs.xgnomon; yp = cs.yPole + cs.ygnomon; zp = (cs.epaisseur /* + cs.egnomon*/) / 2
				xg = cs.xgnomon; yg = cs.ygnomon; zg = cs.hgnomon + (cs.epaisseur /*+ cs.egnomon*/) / 2
				let v1 = new THREE.Vector3(xp, yp, zp) // pied  style droit
				let v2 = new THREE.Vector3(xg, yg, zg) // sommet style droit				
				let v3 = new THREE.Vector3(xp, yp, zp)  //pole du style (si existe!)
				let v4 = new THREE.Vector3(xg, yg, zp)  // bis, il faut 4 points pour ConvexGeometry
				cs.hgnomonBord = 0
				//console.log( [v1,v2,v3,v4])
				if ((!pointDansCadran(xp, yp)) && (pointDansCadran(xg, yg))) {
					let alpha = Math.atan((cs.xPole / cs.yPole)) * 180 / Math.PI  //angle: sousstylaire avec verticale
					if (TracerFil(90 - alpha, 0, 0)) {                            // appel algo des cadrans bifilaires-> intersections avec les bords
						let tanSS = Math.tan(cs.angleStyleSousstylaire * Math.PI / 180)
						h1 = Math.sqrt((xp - x10) * (xp - x10) + (yp - y10) * (yp - y10)) * tanSS
						h2 = Math.sqrt((xp - x20) * (xp - x20) + (yp - y20) * (yp - y20)) * tanSS
						if (h1 <= h2) {
							cs.hgnomonBord = h1
							v1 = new THREE.Vector3(x10, y10, zp + h1)
							v3 = new THREE.Vector3(x10, y10, zp)
						} else {
							cs.hgnomonBord = h2
							v1 = new THREE.Vector3(x20, y20, zp + h2)
							v3 = new THREE.Vector3(x20, y20, zp)
						}
					}
				}
				//console.log("->", [v1,v2,v3,v4])
				let GeometryBout = new THREE.SphereGeometry(cs.egnomon, 32, 16);
				BoutStyle = new THREE.Mesh(GeometryBout, materialGnomon);
				BoutStyle.castShadow = true
				cadranSolaireGroup.add(BoutStyle)
				BoutStyle.position.set(xg, yg, zg)
				BoutStyle.visible = cs.vstyle
				if ((cs.angleStyleSousstylaire != 0) && (cs.angleStyleSousstylaire != 90)) {
					FinStyle = new THREE.Mesh(GeometryBout, materialGnomon);
					cadranSolaireGroup.add(FinStyle)
					FinStyle.castShadow = true
					FinStyle.position.set(v1.x, v1.y, v1.z)
					FinStyle.visible = cs.vstyle

					let tubeGeometrySB = new THREE.TubeGeometry(new THREE.LineCurve3(v1, v3), 16, cs.egnomon, 8);
					styleBord = new THREE.Mesh(tubeGeometrySB, materialGnomon);
					styleBord.castShadow = true
					cadranSolaireGroup.add(styleBord)
					styleBord.visible = cs.vstyle

					let tubeGeometrySP = new THREE.TubeGeometry(new THREE.LineCurve3(v1, v2), 16, cs.egnomon, 8);
					stylePolaire = new THREE.Mesh(tubeGeometrySP, materialGnomon);
					stylePolaire.castShadow = true
					cadranSolaireGroup.add(stylePolaire)
					stylePolaire.visible = cs.vstyle

					let tubeGeometrySS = new THREE.TubeGeometry(new THREE.LineCurve3(v3, v4), 16, cs.egnomon, 8);
					sousStylaire = new THREE.Mesh(tubeGeometrySS, materialGnomon);
					sousStylaire.castShadow = true
					cadranSolaireGroup.add(sousStylaire)
					sousStylaire.visible = cs.vsousstyle
					// const v1d=v1.addScalar(cs.egnomon*0.5)  [v1d,v2d,v3d,v4d,v1g,v2g,v3g,v4g] 
					// const v2d=v2.addScalar(cs.egnomon*0.5)
					// const v3d=v3.addScalar(cs.egnomon*0.5)
					// const v4d=v4.addScalar(cs.egnomon*0.5)
					// const v1g=v1.addScalar(-cs.egnomon*0.5)
					// const v2g=v2.addScalar(-cs.egnomon*0.5)
					// const v3g=v3.addScalar(-cs.egnomon*0.5)
					// const v4g=v4.addScalar(-cs.egnomon*0.5)

					stylePlan = new THREE.Mesh(new ConvexGeometry([v1, v2, v3, v4]), materialGnomon)	//triangle ou trapeze				
					stylePlan.castShadow = true
					//stylePlan.receiveShadow = true
					cadranSolaireGroup.add(stylePlan)
					stylePlan.visible = cs.vsousstyle
				}//catch (e) { }

				cadranSolaireGroup.add(gnomon)

				ligneSVG(v1.x, v1.y, v4.x, v4.y)
				croixSVG(v4.x, v4.y)

			}//SP

			if (cs.typeCadran == BF) {
				calculg1g2k1k2()
				if (cs.anglefilVertical == 90) {
					v10 = new THREE.Vector3(cs.xgnomon, -cs.hauteur / 2, (cs.epaisseur / 2 + cs.hfilVertical));
					v20 = new THREE.Vector3(cs.xgnomon, cs.hauteur / 2, (cs.epaisseur / 2 + cs.hfilVertical))
				}
				else TracerFil(cs.anglefilVertical, cs.hfilVertical, cs.hfilVertical);
				cs.xB1 = v10.x; cs.yB1 = v10.y; cs.xB2 = v20.x; cs.yB2 = v20.y;
				const tubeGeometryFV = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v20), 16, cs.egnomon, 16);
				filVertical = new THREE.Mesh(tubeGeometryFV, materialGnomon);
				filVertical.castShadow = true;
				cadranSolaireGroup.add(filVertical);

				if (cs.anglefilHorizontal == 0) {
					v10 = new THREE.Vector3(-cs.largeur / 2, cs.ygnomon, (cs.epaisseur / 2 + cs.hfilHorizontal));
					v20 = new THREE.Vector3(cs.largeur / 2, cs.ygnomon, (cs.epaisseur / 2 + cs.hfilHorizontal))
				}
				else TracerFil(cs.anglefilHorizontal, cs.hfilHorizontal, cs.hfilHorizontal);
				cs.xA1 = v10.x; cs.yA1 = v10.y; cs.xA2 = v20.x; cs.yA2 = v20.y;
				const tubeGeometryFH = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v20), 16, cs.egnomon, 16);
				filHorizontal = new THREE.Mesh(tubeGeometryFH, materialGnomon);
				filHorizontal.castShadow = true;
				cadranSolaireGroup.add(filHorizontal)

				gnomon.visible = false;
				cadranSolaireGroup.remove(gnomon)
				croixSVG(cs.xA1, cs.yA1); croixSVG(cs.xA2, cs.yA2); croixSVG(cs.xB1, cs.yB1); croixSVG(cs.xB2, cs.yB2)
				croixSVG(cs.xgnomon, cs.ygnomon)

			}//BF

			if (cs.typeCadran == BFG) {

				if (cs.anglefilVertical == 90) {
					v10 = new THREE.Vector3(cs.xgnomon, -cs.hauteur / 2, (cs.epaisseur / 2 + cs.hB1));
					v20 = new THREE.Vector3(cs.xgnomon, cs.hauteur / 2, (cs.epaisseur / 2 + cs.hB2))
				}
				else TracerFil(cs.anglefilVertical, cs.hB1, cs.hB2);
				cs.xB1 = v10.x; cs.yB1 = v10.y; cs.xB2 = v20.x; cs.yB2 = v20.y;
				const tubeGeometryFV = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v20), 16, cs.egnomon, 8);
				filVertical = new THREE.Mesh(tubeGeometryFV, materialGnomon);
				filVertical.castShadow = true;
				cadranSolaireGroup.add(filVertical);
				v30 = new THREE.Vector3(v10.x, v10.y, -cs.epaisseur / 2)
				const tubeGeometryH1 = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v30), 16, cs.egnomon, 8);
				pilierH1 = new THREE.Mesh(tubeGeometryH1, materialGnomon);
				v40 = new THREE.Vector3(v20.x, v20.y, -cs.epaisseur / 2)
				const tubeGeometryH2 = new THREE.TubeGeometry(new THREE.LineCurve3(v20, v40), 16, cs.egnomon, 8);
				pilierH2 = new THREE.Mesh(tubeGeometryH2, materialGnomon);
				cadranSolaireGroup.add(pilierH1); cadranSolaireGroup.add(pilierH2);

				if (cs.anglefilHorizontal == 0) {
					v10 = new THREE.Vector3(-cs.largeur / 2, cs.ygnomon, (cs.epaisseur / 2 + cs.hA1));
					v20 = new THREE.Vector3(cs.largeur / 2, cs.ygnomon, (cs.epaisseur / 2 + cs.hA2))
				}
				else TracerFil(cs.anglefilHorizontal, cs.hA1, cs.hA2);
				cs.xA1 = v10.x; cs.yA1 = v10.y; cs.xA2 = v20.x; cs.yA2 = v20.y;
				const tubeGeometryFH = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v20), 16, cs.egnomon, 8);
				filHorizontal = new THREE.Mesh(tubeGeometryFH, materialGnomon);
				filHorizontal.castShadow = true;
				cadranSolaireGroup.add(filHorizontal)
				v30 = new THREE.Vector3(v10.x, v10.y, -cs.epaisseur / 2)
				const tubeGeometryH3 = new THREE.TubeGeometry(new THREE.LineCurve3(v10, v30), 16, cs.egnomon, 8);
				pilierH3 = new THREE.Mesh(tubeGeometryH3, materialGnomon);
				v40 = new THREE.Vector3(v20.x, v20.y, -cs.epaisseur / 2)
				const tubeGeometryH4 = new THREE.TubeGeometry(new THREE.LineCurve3(v20, v40), 16, cs.egnomon, 8);
				pilierH4 = new THREE.Mesh(tubeGeometryH4, materialGnomon);
				cadranSolaireGroup.add(pilierH3); cadranSolaireGroup.add(pilierH4);

				croixSVG(cs.xA1, cs.yA1); croixSVG(cs.xA2, cs.yA2); croixSVG(cs.xB1, cs.yB1); croixSVG(cs.xB2, cs.yB2)
				croixSVG(cs.xgnomon, cs.ygnomon)
				gnomon.visible = false;

			}//BFG

			if (cs.typeCadran == ANL) {
				if (cs.zdirect == 0) cs.zdirect = 0.1;
				var k = Math.sqrt(1 + Math.tan(base.toRad(cs.xdirect)) ** 2 + Math.tan(base.toRad(cs.ydirect)) ** 2);
				xd = Math.tan(base.toRad(cs.xdirect)) / k; yd = Math.tan(base.toRad(cs.ydirect)) / k;
				k = cs.Ranalem * cs.zdirect / 100;
				zd = k * Math.sqrt(1 - xd ** 2 - yd ** 2); xd *= k; yd *= k;
				const ct = new THREE.Vector3(xd + cs.xgnomon, yd + cs.ygnomon, zd + cs.epaisseur / 2);
				const pj = Proj(EtoC(0, 0, Math.tan(TS.decSuns[cs.dayofYear - 1])));
				pj.z = Math.abs(pj.z);
				const xp = pj.x - cs.xgnomon, yp = pj.y - cs.ygnomon;
				const v1 = cs.Canalem && (zd < 0) ? new THREE.Vector3(ct.x, ct.y, ct.z) : new THREE.Vector3(pj.x, pj.y, pj.z);

				var v2;
				if (!cs.Canalem) {
					k = cs.Hanalem / k;
					v2 = new THREE.Vector3(pj.x + k * xd, pj.y + k * yd, pj.z + k * zd);
				} else
					if (zd < 0) {
						k = (cs.Hanalem - k) / Math.sqrt((xd - xp) ** 2 + (yd - yp) ** 2 + zd ** 2);
						v2 = new THREE.Vector3(ct.x + k * (xp - xd), ct.y + k * (yp - yd), ct.z - k * zd);
					} else {
						k = cs.Hanalem / Math.sqrt((xd - xp) ** 2 + (yd - yp) ** 2 + zd ** 2);
						v2 = new THREE.Vector3(pj.x + k * (xd - xp), pj.y + k * (yd - yp), pj.z + k * zd);
					}

				const tubeGeometry = new THREE.TubeGeometry(new THREE.LineCurve3(v1, v2), 16, cs.egnomon, 32);
				styleAnalem = new THREE.Mesh(tubeGeometry, materialGnomon);
				styleAnalem.castShadow = true;
				cadranSolaireGroup.add(styleAnalem);
				if (cs.Canalem) {
					const centreGeometry = new THREE.SphereGeometry(3 * cs.egnomon);
					centreAnalem = new THREE.Mesh(centreGeometry, materialGnomon);
					centreAnalem.castShadow = true;
					centreAnalem.position.set(ct.x, ct.y, ct.z);
					cadranSolaireGroup.add(centreAnalem);
				}
			}//ANL

			if (cs.typeCadran == STP) {
				// const materialGnomon = new THREE.MeshStandardMaterial(
				// 	{ transparent: true, opacity: 1, roughness: 0.5, metalness: 0.5, side: THREE.DoubleSide, color: 0xffffff , map: textureBois /*,clippingPlanes:clipPlanes */ });
				// Calcul du point du profil pour le jour julien jj
				const materialGnomon = materialCS
				function pProfil(jj) {
					const a = cs.a * Math.PI / 180, dc = apparentEquatorial(jj).dec, eq = EQTIME.eSmart(jj);
					let r, z;
					if (cs.appx) {				// Calcul approché
						z = Math.cos(eq + a) * Math.tan(dc);
						r = Math.abs(Math.sin(eq + a));
					} else {
						const eps = 0.1;
						const xc = Math.cos(eq + a) * Math.cos(dc), yc = -Math.sin(eq + a) * Math.cos(dc), zc = Math.sin(dc);
						const dcm = apparentEquatorial(jj - eps).dec, dcp = apparentEquatorial(jj + eps).dec;
						const eqm = EQTIME.eSmart(jj - eps), eqp = EQTIME.eSmart(jj + eps);
						let xcp = Math.cos(eqp + a) * Math.cos(dcp), ycp = -Math.sin(eqp + a) * Math.cos(dcp), zcp = Math.sin(dcp);
						xcp -= Math.cos(eqm + a) * Math.cos(dcm); ycp -= -Math.sin(eqm + a) * Math.cos(dcm), zcp -= Math.sin(dcm);
						const T = xcp * zc - xc * zcp;
						const V = T / (xc * T + yc * (ycp * zc - yc * zcp));
						z = V * zc;
						r = Math.sqrt((V * xc - 1) ** 2 + (V * yc) ** 2);
					}
					return { z: z, r: r };
				}

				// Calcul du profil avec ou sans le rebroussement
				const j0 = JULIAN.CalendarGregorianToJD(cs.year, 1, 1.5), profi = [], inc = (cs.sais) ? 1 : -1;
				let prof, zp, rp, bl1 = true, bl2 = true, cd = true, njc, Jour = [], j, dateJour;
				for (let nj = TS.jdecSunMax; cd; nj += inc) {
					njc = nj; if (nj < 0) njc += TS.ascRights.length;
					if (inc * Math.cos(TS.ascRights[njc]) < 0) {
						prof = pProfil(njc + j0);
						if (bl1) bl1 = false;				// Première boucle valide, on ne fait rien.
						else if (cs.reb || prof.z < zp) {
							if (bl2) {								// Premier cas valide, on prend le point précédent.
								profi.push(new THREE.Vector2(rp, zp));
								bl2 = false;
							}
							profi.push(new THREE.Vector2(prof.r, prof.z));
						}
						zp = prof.z; rp = prof.r;
						Jour.push(njc + j0)
					}
					cd = (cs.sais) ? nj <= TS.jdecSunMin : nj + TS.ascRights.length >= TS.jdecSunMin;

				}

				// Limitation du profil à Rmax
				const rm = cs.Rmax / 100, profil = [];
				let p, pp;
				for (let i = 0; i < profi.length; i++) {
					p = profi[i];
					if (i != 0) {				// On ne fait rien pour le premier point
						if (pp.x < rm && p.x < rm) {
							profil.push(pp);
						} else if (pp.x < rm && p.x >= rm) {
							profil.push(pp); profil.push(new THREE.Vector2(rm, pp.y + (p.y - pp.y) * (rm - pp.x) / (p.x - pp.x)));
						} else if (pp.x >= rm && p.x < rm) {
							profil.push(new THREE.Vector2(rm, pp.y + (p.y - pp.y) * (rm - pp.x) / (p.x - pp.x)));
						}
					}
					pp = p;
				}
				if (pp.x < rm) profil.push(pp);

				//style
				const geometrySTP = new THREE.LatheGeometry(profil, 128);
				styleSTP = new THREE.Mesh(geometrySTP, materialGnomon);
				const rc = kSTP * cs.largeur;			// Rayon interne du cylindre
				styleSTP.scale.x = rc; styleSTP.scale.y = rc; styleSTP.scale.z = rc;
				styleSTP.rotateY(Math.PI)
				styleSTP.castShadow = true;
				cadran.castShadow = true
				styleSTP.receiveShadow = true
				cadranSolaireGroup.add(styleSTP);

				//sortie csv
				CSVtext += "\n\n"
				CSVtext += "Profile of the style\n" + "\n"
				CSVtext += "Day:" + cs.separateurCSV + "Radius" + cs.separateurCSV + "y" + "\n";
				for (let i = 0; i < profil.length; i++) {
					const rs = profil[i].x * rc
					const zs = profil[i].y * rc
					dateJour = JULIAN.JDToCalendarGregorian(Jour[i])
					CSVtext += Math.floor(dateJour.day) + "/" + dateJour.month + cs.separateurCSV + rs.toFixed(3) + cs.separateurCSV + zs.toFixed(3) + "\n";
				}

				//disques haut et bas
				if (geometryCircle1STP !== undefined) { geometryCircle1STP.dispose(); cadranSolaireGroup.remove(circle1STP) }
				geometryCircle1STP = new THREE.CircleGeometry(profil[profil.length - 1].x * rc, 32);
				circle1STP = new THREE.Mesh(geometryCircle1STP, materialGnomon)
				circle1STP.rotateX(Math.PI / 2)
				circle1STP.position.y = profil[profil.length - 1].y * rc
				cadranSolaireGroup.add(circle1STP);
				if (geometryCircle2STP !== undefined) { geometryCircle2STP.dispose(); cadranSolaireGroup.remove(circle2STP) }
				geometryCircle2STP = new THREE.CircleGeometry(profil[0].x * rc, 32);
				circle2STP = new THREE.Mesh(geometryCircle2STP, materialGnomon)
				circle2STP.rotateX(Math.PI / 2)
				circle2STP.position.y = profil[0].y * rc
				cadranSolaireGroup.add(circle2STP);
				//supports
				if (axeSTP !== undefined) {
					cadranSolaireGroup.remove(supportSTPsup); cadranSolaireGroup.remove(supportSTPinf); cadranSolaireGroup.remove(axeSTP)
				}
				if (cs.support) {
					if (geometrySupportSTP !== undefined) { geometrySupportSTP.dispose() }
					geometrySupportSTP = new THREE.BoxGeometry(cs.largeur + 0.2 * rc / 2, 0.025 * rc, 0.025 * rc)
					supportSTPsup = new THREE.Mesh(geometrySupportSTP, materialCS)
					supportSTPsup.position.y = cs.hauteur / 2//-0.025*rc
					supportSTPinf = supportSTPsup.clone()
					supportSTPinf.position.y = -supportSTPsup.position.y
					supportSTPsup.castShadow = true
					supportSTPinf.castShadow = true
					if (geometryAxeSTP !== undefined) { geometryAxeSTP.dispose() }
					geometryAxeSTP = new THREE.CylinderGeometry(0.01 * rc, 0.01 * rc, cs.hauteur - 0.025 * rc)
					axeSTP = new THREE.Mesh(geometryAxeSTP, materialCS)
					axeSTP.castShadow = true
					cadranSolaireGroup.add(supportSTPsup)
					cadranSolaireGroup.add(supportSTPinf)
					cadranSolaireGroup.add(axeSTP)
				}

			}//STP

		}  //Tracer Style



		//------------------------------------------------------------------------------------------------------
		function ExtrudeSetting(c, spline, nsteps) {
			const squareShape = new THREE.Shape()
				.moveTo(0, c)
				//	.lineTo(  -c,c )
				.lineTo(-2 * c, 0)
				//	.lineTo(  -c, -c)
				.lineTo(0, -c)
				.lineTo(0, c);
			const Settings = {
				steps: nsteps,
				bevelEnabled: false,
				extrudePath: spline
			};
			return { forme: squareShape, setting: Settings }
		}
		// const ES=ExtrudeSetting (cs.egnomon,pipeSplineCRC,200)
		// tubeGeometry = new THREE.ExtrudeGeometry(ES.forme,ES.setting); 
		// mesh = new THREE.Mesh( tubeGeometry, material);
		//---------------------------------------------------------------------------------------------------------
		function effacelisteMesh(listeMesh, group) {
			if (group == undefined) { return }
			const lm = listeMesh.length;
			let mesh, geo;
			for (let i = 0; i < lm; i++) {
				mesh = listeMesh[i];
				geo = mesh.geometry
				geo.dispose();
				group.remove(mesh);
				//mesh.clear
				//console.log(geo)
			}
			//listeMesh = [];
			listeMesh.splice(0, listeMesh.length);
			//group.clear()
			cadranSolaireGroup.remove(group)
			// if (group == undefined) { return }
			// while (group.children.length > 0) {
			// 	const mesh = group.children[0];
			// 	if (mesh.geometry !== undefined) { mesh.geometry.dispose() };
			// 	group.remove(mesh);
			// }
			// cadranSolaireGroup.remove(group)
		}

		//-----------------------------------------------------------------------------------------------------------------------
		function traceLignes(sunDial, listeMesh, group, material) {
			let tubeGeometry, mesh, xp, yp, zp, pipeSpline, pipeSplineCRC, longLigne, xs, ys, eptrait, hd, h, min;
			// tracé des nouvelles lignes

			for (let i = 0; i < sunDial.lines.length; i++) {
				longLigne = sunDial.lines[i].points.length
				if (longLigne > 1) {
					hd = sunDial.lines[i].hour;
					h = Math.floor(hd);
					min = Math.round((hd - h) * 60);
					CSVtext += "Heure: " + h.toString() + ":" + min.toString() + "\n";
					pipeSpline = [];
					if (presqueEntier(sunDial.lines[i].hour)) { eptrait = cs.egnomon } else { eptrait = cs.egnomon / 2 }
					if (SVGtext.length > 0) {
						SVGtext += ` 
				          <polyline fill="none" stroke="${material.color.getStyle()}" stroke-width="${eptrait}"
				           points= " ` }

					for (let p = 0; p < sunDial.lines[i].points.length; p++) {
						xp = sunDial.lines[i].points[p].x + cs.xgnomon;
						yp = sunDial.lines[i].points[p].y + cs.ygnomon;
						zp = sunDial.lines[i].points[p].z + cs.egnomon / 2;

						pipeSpline.push(new THREE.Vector3(xp, yp, zp));
						ligneCSV("point:", xp, yp, zp)
						pointSVG(xp, yp)
						
					};
					if (SVGtext.length > 0) { SVGtext += `" />` }
					if (pipeSpline.length > 1) {
						pipeSplineCRC = [];
						pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline, false, 'chordal', 0.5);


						tubeGeometry = new THREE.TubeGeometry(pipeSplineCRC, 180, eptrait, 8, false);

						//const ES=ExtrudeSetting (cs.egnomon,pipeSplineCRC,180)
						//tubeGeometry = new THREE.ExtrudeGeometry(ES.forme,ES.setting); 

						mesh = new THREE.Mesh(tubeGeometry, material);
						mesh.receiveShadow = true;
						listeMesh.push(mesh);
						group.add(mesh);
					}
					cadranSolaireGroup.add(group)
					//if(RTSpolyhedre()){meshFaces[nfaceActive].add(group)}
				}
			}

			//   TracerStyle()
		}
		// const ES=ExtrudeSetting (cs.egnomon,pipeSplineCRC,200)
		// tubeGeometry = new THREE.ExtrudeGeometry(ES.forme,ES.setting); 
		// mesh = new THREE.Mesh( tubeGeometry, material);

		// const lineGeometry = new THREE.BufferGeometry().setFromPoints( pipeSplineCRC );				   
		// const lineMaterial = new THREE.LineBasicMaterial( {color:0x0000FF});
		// mesh = new THREE.Mesh( lineGeometry, lineMaterial);		 

		//---------------------------------------------------------------------------------------------------------
		function TracerHeuresSolaires() {
			cs.hoursTextSize = cs.textSizeHS
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, HS, heuresSolairesGroup, materialHeuresSolaires, heuresSolairesListeMesh);
			//console.log(CSVtext)
			CSVtext += "\n\n"
			CSVtext += 'Solar hours' + "\n\n"
			//if (SVGtext.length > 0) {SVGtext+='<g id="HSol" >'}
			traceLignes(sunDial, heuresSolairesListeMesh, heuresSolairesGroup, materialHeuresSolaires)
			//if (SVGtext.length > 0) {SVGtext+='</g>'}

		}

		//-------------------------------------------------------------------------------------------------------
		function TracerHeuresLegalesSA() {
			cs.hoursTextSize = cs.textSizeSA
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMax, TS.jdecSunMin, HLSA, heuresLegalesGroupSA, materialHeuresLegalesSA, heuresLegalesListeMeshSA);
			CSVtext += "\n\n"
			CSVtext += 'Legal hours (Summer and Autumn)' + "\n\n"

			traceLignes(sunDial, heuresLegalesListeMeshSA, heuresLegalesGroupSA, materialHeuresLegalesSA)

		}

		function TracerHeuresLegalesWS() {

			cs.hoursTextSize = cs.textSizeWS
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax + 1, HLWS, heuresLegalesGroupWS, materialHeuresLegalesWS, heuresLegalesListeMeshWS);
			CSVtext += "\n\n"
			CSVtext += 'Legal hours (Winter and Spring)' + "\n\n"

			traceLignes(sunDial, heuresLegalesListeMeshWS, heuresLegalesGroupWS, materialHeuresLegalesWS)

		}

		//------------------------------------------------------------------------------------------------
		function TracerHeuresAntiques() {
			if (Math.abs(cs.lati) >= 66.6) {
				alert('Unequal hours make no sense in arctic latitudes');
				cadranSolaireGroup.remove(heuresAntiquesGroup);
				return
			}
			cs.hoursTextSize = cs.textSizeHA
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, HA, heuresAntiquesGroup, materialHeuresAntiques, heuresAntiquesListeMesh);
			CSVtext += "\n\n"
			CSVtext += 'Antic hours' + "\n\n"

			traceLignes(sunDial, heuresAntiquesListeMesh, heuresAntiquesGroup, materialHeuresAntiques)
		}
		//-----------------------------------------------------------------------------------------------------
		function TracerHeuresBabyloniques() {
			if (Math.abs(cs.lati) >= 66.6) {
				alert('Babylonics hours make no sense in arctic latitudes');
				cadranSolaireGroup.remove(heuresBabyloniquesGroup);
				return
			}
			cs.hoursTextSize = cs.textSizeHB;
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, HB, heuresBabyloniquesGroup, materialHeuresBabyloniques, heuresBabyloniquesListeMesh);
			CSVtext += "\n\n"
			CSVtext += 'Babylonics hours' + "\n\n"

			traceLignes(sunDial, heuresBabyloniquesListeMesh, heuresBabyloniquesGroup, materialHeuresBabyloniques)

		}
		//-----------------------------------------------------------------------------------------------------
		function TracerHeuresItaliques() {
			if (Math.abs(cs.lati) >= 66.6) {
				alert('Italic hours make no sense in arctic latitudes');
				cadranSolaireGroup.remove(heuresItaliquesGroup);
				return
			}
			cs.hoursTextSize = cs.textSizeHI;
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMax, TS.jdecSunMin, HI, heuresItaliquesGroup, materialHeuresItaliques, heuresItaliquesListeMesh);
			CSVtext += "\n\n"
			CSVtext += 'Italic hours' + "\n\n"

			traceLignes(sunDial, heuresItaliquesListeMesh, heuresItaliquesGroup, materialHeuresItaliques)

		}

		//------------------------------------------------------------------------------------------------------
		function TracerHeuresSDSA() {
			cs.hoursTextSize = cs.textSizeSDSA;
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMax, TS.jdecSunMin, HSDSA, heuresSDSAgroup, materialHeuresSDSA, heuresSDSAListeMesh);
			CSVtext += "\n\n"
			CSVtext += HSDSA + "\n\n"

			traceLignes(sunDial, heuresSDSAListeMesh, heuresSDSAgroup, materialHeuresSDSA)
		}

		function TracerHeuresSDWS() {
			cs.hoursTextSize = cs.textSizeSDWS;
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, HSDWS, heuresSDWSgroup, materialHeuresSDWS, heuresSDWSListeMesh);
			CSVtext += "\n\n"
			CSVtext += HSDWS + "\n\n"

			traceLignes(sunDial, heuresSDWSListeMesh, heuresSDWSgroup, materialHeuresSDWS)

		}

		//---------------------------------------------------------------------------------------------------------

		function TracerHeuresHPSA() {
			cs.hoursTextSize = cs.textSizeHPSA;
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMax, TS.jdecSunMin, HPSA, heuresHPSAgroup, materialHeuresHPSA, heuresHPSAListeMesh);
			CSVtext += "\n\n"
			CSVtext += HPSA + "\n\n"

			traceLignes(sunDial, heuresHPSAListeMesh, heuresHPSAgroup, materialHeuresHPSA)
		}

		function TracerHeuresHPWS() {
			cs.hoursTextSize = cs.textSizeHPWS;
			//console.log(heuresHPWSListeMesh)
			const sunDial = generalAJL
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, HPWS, heuresHPWSgroup, materialHeuresHPWS, heuresHPWSListeMesh);
			CSVtext += "\n\n"
			CSVtext += HPWS + "\n\n"

			traceLignes(sunDial, heuresHPWSListeMesh, heuresHPWSgroup, materialHeuresHPWS)

		}

		//---------------------------------------------------------------------------------------------------------
		function TracerArcsDiurnes() {
			let tubeGeometry, mesh, xp, yp, zp, lm, pipeSpline, pipeSplineCRC, xs, ys;
			//console.log(cs.datesArcsDiurnes)
			//if(typeof(cs.datesArcsDiurnes==undefined)){return}
			if (typeof (cs.datesArcsDiurnes) == "undefined") { return }
			effacelisteMesh(arcsDiurnesListeMesh, arcsDiurnesGroup)

			const sunDial = arcsDiurnes
				(base.toRad(cs.lati), base.toRad(-cs.decli), cs.hgnomon, base.toRad(cs.incli),
					TS.jdecSunMin, TS.jdecSunMax, arcsDiurnesGroup, materialArcsDiurnes, arcsDiurnesListeMesh);


			CSVtext += "\n\n";
			CSVtext += "Diurnial arcs" + "\n\n";

			//traceLignes(sunDial,arcsDiurnesListeMesh,arcsDiurnesGroup,materialArcsDiurnes)
			// tracé des nouvelles lignes
			for (let i = 0; i < sunDial.lines.length; i++) {
				if (sunDial.lines[i].points.length > 1) {
					CSVtext += "Date: " + sunDial.lines[i].date[0].toString() + "\n";
					pipeSpline = [];
					if (SVGtext.length > 0) {
						SVGtext += ` 
				          <polyline fill="none" stroke="${materialArcsDiurnes.color.getStyle()}" stroke-width="${cs.egnomon}"
				           points= " ` }

					for (let p = 0; p < sunDial.lines[i].points.length; p++) {
						xp = sunDial.lines[i].points[p].x + cs.xgnomon;
						yp = sunDial.lines[i].points[p].y + cs.ygnomon;
						zp = sunDial.lines[i].points[p].z + cs.egnomon / 2;
						pipeSpline.push(new THREE.Vector3(xp, yp, zp));
						ligneCSV("point: ", xp, yp, zp)
						//CSVtext += "point: " + cs.separateurCSV + xp.toFixed(2) + cs.separateurCSV + yp.toFixed(2) + "\n"
						if (SVGtext.length > 0) {
							xs = xp + cs.largeur / 2; ys = -yp + cs.hauteur / 2
							SVGtext += `${xs.toFixed(3)},${ys.toFixed(3)}   `
						}
					};
					if (SVGtext.length > 0) { SVGtext += `" />` }
					if (pipeSpline.length > 1) {
						pipeSplineCRC = [];
						pipeSplineCRC = new THREE.CatmullRomCurve3(pipeSpline, false, 'chordal', 0);
						tubeGeometry = new THREE.TubeGeometry(pipeSplineCRC, 200, cs.egnomon, 8, false);
						mesh = new THREE.Mesh(tubeGeometry, materialArcsDiurnes);
						mesh.receiveShadow = true;
						arcsDiurnesListeMesh.push(mesh);
						arcsDiurnesGroup.add(mesh);
					}
				}
			}
			//TracerStyle(sunDial)
			cadranSolaireGroup.add(arcsDiurnesGroup);
			

		}

		/**
		 * Point return type represents a point to be used in constructing the sundial.
		 */
		function Point(x, y, z) {
			this.x = x || 0
			this.y = y || 0
			this.z = z || 0
		}

		/**
		 * Line holds data to draw an hour line on the sundial.
		 */
		function LigneHoraire(hour, points) {
			this.hour = hour // 0 to 24
			this.points = points || [] // One or more points corresponding to the hour.
		}

		function LigneArc(date, points) {
			this.date = date
			this.points = points || [] // One or more points corresponding to the date.
		}

		/**
		 * General computes data for the general case of a planar sundial.
		 *
		 * Argument φ is geographic latitude at which the sundial will be located.
		 * D is gnomonic declination, the azimuth of the perpendicular to the plane
		 * of the sundial, measured from the southern meridian towards the west.
		 * Argument a is the length of a straight stylus perpendicular to the plane
		 * of the sundial, z is zenithal distance of the direction defined by the
		 * stylus.  Angles φ, D, and z are in radians.  Units of stylus length a
		 * are arbitrary.
		 *
		 * Results consist of a set of lines, a center point, u, the length of a
		 * polar stylus, and ψ, the angle which the polar stylus makes with the plane
		 * of the sundial.  The center point, the points defining the hour lines, and
		 * u are in units of a, the stylus length.  ψ is in radians.
		 */

		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////
		function Correction(H0, j) {
			let c = 0
			c = TS.eqtimes[j] + (cs.longi / 15 - cs.offset_sec / 3600) * Math.PI / 12;
			return (H0 + c);  //angle horaire en radians, de -pi à +pi
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////
		function coordOmbre(sH, cH, sD, cD, sz, cz, sφ, cφ, tδ, Q, H, dec) {

			if (cs.typeCadran == SP) {
				const Nx = cD * sH - sD * (sφ * cH - cφ * tδ)
				const Ny = cz * sD * sH - (cφ * sz - sφ * cz * cD) * cH - (sφ * sz + cφ * cz * cD) * tδ
				return {
					xo: cs.hgnomon * Nx / Q,
					yo: cs.hgnomon * Ny / Q,
					zo: cs.epaisseur / 2,
					ok: true
				}
			}
			if (cs.typeCadran == BF) {
				const Dn = sD * sH + cD * (sφ * cH - cφ * tδ)
				const Nx = (g1 * (cD * sH - sD * (sφ * cH - cφ * tδ)) + k1 * (sφ * tδ + cφ * cH)) / Dn
				const Ny = (g2 * (sφ * tδ + cφ * cH) + k2 * (cD * sH - sD * (sφ * cH - cφ * tδ))) / Dn
				return {
					xo: -Nx,
					yo: -Ny,
					zo: cs.epaisseur / 2,
					ok: true
				}
			}
			if (cs.typeCadran == BFG) {
				const Nx = cD * sH - sD * (sφ * cH - cφ * tδ)
				const Ny = cz * sD * sH - (cφ * sz - sφ * cz * cD) * cH - (sφ * sz + cφ * cz * cD) * tδ
				const xA1 = cs.hA1 * Nx / Q + cs.xA1  //algorythme Hugo: coord des points d'ombre des supports
				const yA1 = cs.hA1 * Ny / Q + cs.yA1
				const xA2 = cs.hA2 * Nx / Q + cs.xA2
				const yA2 = cs.hA2 * Ny / Q + cs.yA2
				const xB1 = cs.hB1 * Nx / Q + cs.xB1
				const yB1 = cs.hB1 * Ny / Q + cs.yB1
				const xB2 = cs.hB2 * Nx / Q + cs.xB2
				const yB2 = cs.hB2 * Ny / Q + cs.yB2
				const a = yA2 - yA1; const b = -xA2 + xA1;    //coefs droite A1A2: a x + b y =c
				const c = xA1 * (yA2 - yA1) - yA1 * (xA2 - xA1)
				const ap = yB2 - yB1; const bp = -xB2 + xB1;  //coefs droite B1B2: ap x + bp y = cp
				const cp = xB1 * (yB2 - yB1) - yB1 * (xB2 - xB1)
				let det = a * bp - ap * b
				const xombre = (bp * c - b * cp) / det
				const yombre = (a * cp - ap * c) / det
				// const kxA = (xombre - xA1) / (xA2 - xA1)
				// const kxB = (xombre - xB1) / (xB2 - xB1)
				// if ((kxA < 0) || (kxA > 1) || (kxB < 0) || (kxB > 1)) { det = 0 }

				if (pointDansCadran(xombre, yombre)) {
					return {
						xo: xombre - cs.xgnomon,
						yo: yombre - cs.ygnomon,
						zo: cs.epaisseur / 2,
						ok: true
					}
				} else {
					return {
						xo: 0,
						yo: 0,
						zo: 0,
						ok: false
					}
				}
			}
			if (cs.typeCadran == RTS) {
				const Coord = CoordRayTracing(H, dec)
				//console.log(Coord)
				if (Coord.ok) {
					return {
						xo: Coord.x - cs.xgnomon,
						yo: Coord.y - cs.ygnomon,
						zo: Coord.z,
						ok: Coord.ok
					}
				} else {
					return {
						xo: 0,
						yo: 0,
						zo: 0,
						ok: false
					}
				}
			}
		}


		function presqueEntier(x) {
			return (Math.abs(Math.round(x) - x) < 0.001)
		}
		// function Modulo2PI(x){
		// 	if(x>Math.PI){}
		// 	if(x<-Math.PI){return x}
		// }
		function generalAJL(φ, D, a, z, debut, fin, TypeHeure, group, material, listeMesh) {
			// (φ, D, a, z float64)  (lines []LigneHoraire, center Point, u, ψ float64)
			let l
			let coupe = false; let gauche = false
			effacelisteMesh(listeMesh, group)
			let H, xp, yp, zp, xm, ym, zm, chiffreH = 0, sHeure = "";
			if (φ * 180 / Math.PI > 89.99) { φ = 89.99 * Math.PI / 180 }
			const [sφ, cφ] = base.sincos(φ)
			const tφ = sφ / cφ
			const [sD, cD] = base.sincos(D)
			const [sz, cz] = base.sincos(z)
			const P = sφ * cz - cφ * sz * cD
			const tan23p44 = Math.tan(23.44 / 180 * Math.PI)
			const sin23p44 = Math.sin(23.44 / 180 * Math.PI)
			const lines = []
			for (let i = 0; i <= 24; i += cs.subDivisions) {
				l = new LigneHoraire(i)
				const Hi = (i - 12) * 15 * Math.PI / 180

				let j = debut;
				while (j !== fin + 1) {
					//if((Math.abs(j-TS.jdecSunMin)<5)||(Math.abs(j-TS.jdecSunMax)<5)){j++}else{j+=cs.precisionHours}
					j++
					if (j >= TS.decSuns.length) { j = 0 }
					if ((j % cs.precisionHours == 0) || (Math.abs(j - TS.jdecSunMin) <= 7) || (Math.abs(j - TS.jdecSunMax) <= 7)) {
						//coupe = false
						const tδ = Math.tan(TS.decSuns[j])
						const sδ = Math.sin(TS.decSuns[j])
						const cosH0 = -tφ * tδ
						let H0 = Math.acos(cosH0)    //half day length 
						if (cosH0 > 1) { H0 = -Math.PI }   //nuit polaire
						if (cosH0 <= -1) { H0 = Math.PI }  //j0ur polaire

						if (TypeHeure == HS) { H = Hi; chiffreH = i }     // Heures solaires
						if ((TypeHeure == HLSA) || (TypeHeure == HLWS)) { H = Correction(Hi, j); chiffreH = i }   //légales
						if (TypeHeure == HA) { H = H0 / 6 * (i - 12); chiffreH = i - 6 }  // heures antiques
						if (TypeHeure == HB) { H = i * 15 / 180 * Math.PI - H0; chiffreH = i }  //heures babyloniques
						if (TypeHeure == HI) { H = (i - 24) * 15 / 180 * Math.PI + H0; chiffreH = i }  //heures italiquesiques

						if (TypeHeure == HSDSA) {
							const RA = Math.PI - Math.asin(tδ / tan23p44) //ascension droite du soleil
							H = i * 15 / 180 * Math.PI - RA
							chiffreH = i
						}
						if (TypeHeure == HSDWS) {
							const RA = Math.asin(tδ / tan23p44)          //ascension droite du soleil
							H = (i - 12) * 15 / 180 * Math.PI - RA
							if ((i - 12) < 0) { chiffreH = i + 12 } else { chiffreH = i - 12 }
						}
						if ((TypeHeure == HPSA) && (i <= 12)) { // il faut prendre le supplémentaire de RE quand RE et LE ne sont pas dans le même cadran.
							const RA = Math.PI - Math.asin(tδ / tan23p44)
							const LS = Math.PI - Math.asin(sδ / sin23p44)
							const LE = LS + i * 15 * Math.PI / 180; chiffreH = i
							const DE = Math.asin(Math.sin(LE) * sin23p44)
							let RE = Math.asin(Math.tan(DE) / tan23p44) + 2 * Math.PI
							if (LE < 3 * Math.PI / 2) { RE = 3 * Math.PI - RE }
							const T = Math.acos(-Math.tan(φ) * Math.tan(DE))
							H = -T - RA + RE
							//if (i==6){console.log(TS.decSuns[j]*180/Math.PI,"RA ° = ",RA*180/Math.PI,"  LE ° = ",LE*180/Math.PI, "   RE ° = ",RE*180/Math.PI)}
							if (i >= 12) { H = 2 * H0 }
						}
						if ((TypeHeure == HPWS) && (i <= 12)) { // il faut prendre le supplémentaire de RE quand RE et LE ne sont pas dans le même cadran.
							const RA = Math.asin(tδ / tan23p44)
							const LS = Math.asin(sδ / sin23p44)
							let LE = LS + i * 15 / 180 * Math.PI; chiffreH = i
							const DE = Math.asin(Math.sin(LE) * sin23p44)
							let RE = Math.asin(Math.tan(DE) / tan23p44)
							if (LE > Math.PI / 2) { RE = Math.PI - RE }
							const T = Math.acos(-Math.tan(φ) * Math.tan(DE))
							H = -T - RA + RE
							//if (i==6){console.log(TS.decSuns[j]*180/Math.PI,"RA ° = ",RA*180/Math.PI,"  LE ° = ",LE*180/Math.PI, "   RE ° = ",RE*180/Math.PI)}
							if (i > 12) { H = 2 * H0 }
						}
						const aH = Math.abs(H)
						const [sH, cH] = base.sincos(H)
						if (aH < H0) { // sun above horizon
							const Q = sD * sz * sH + (cφ * cz + sφ * sz * cD) * cH + P * tδ
							if ((Q > 0) || (cs.typeCadran == RTS)) { // sun above plane of sundial         
								const coord = coordOmbre(sH, cH, sD, cD, sz, cz, sφ, cφ, tδ, Q, H, TS.decSuns[j])       // Calcul des coordonnées de l'ombre
								if (coord.ok == true) {
									xp = coord.xo; yp = coord.yo; zp = coord.zo;
									if (pointDansCadran(xp + cs.xgnomon, yp + cs.ygnomon)) {
										if (coupe) {
											if (l.points.length > 0) { lines.push(l) }
											l = new LigneHoraire(i); coupe = false
										}
										l.points.push(new Point(xp, yp, zp)); xm = xp + cs.xgnomon; ym = yp + cs.ygnomon; zm = zp
									} else { coupe = true }
								} else { coupe = true }
							}
						}

					}
				}
				if (presqueEntier(chiffreH)) { sHeure = Math.round(chiffreH).toString() } else { sHeure = "" };
				if (l.points.length > 0) {
					l.hour = chiffreH    /// correction bug des fichiers csv
					lines.push(l);
					// ((xp + cs.xgnomon)<0)?gauche=false:gauche=true
					// RTSpolyhedre()?gauche=false:
					EcrireTexte(sHeure, xm, ym, zm, material, group, listeMesh)
				}
			}
			const center = new Point()
			center.x = a / P * cφ * sD
			center.y = -a / P * (sφ * sz + cφ * cz * cD)
			const aP = Math.abs(P)
			const u = a / aP
			const ψ = Math.asin(aP)
			cs.xPole = center.x; cs.yPole = center.y; cs.angleStyleSousstylaire = ψ * 180 / Math.PI;
			//console.log (cs.xPole,cs.yPole)
			return {
				lines: lines,
				center: center,
				length: u,
				angle: ψ
			}
		}


		function arcsDiurnes(φ, D, a, z, debut, fin, group, material, listeMesh) {
			// (φ, D, a, z float64)  (lines []LigneHoraire, center Point, u, ψ float64)
			let H, xp, yp, zp, xm, ym, s, coupe, l;

			if (φ * 180 / Math.PI > 89.999999) { φ = 89.999999 * Math.PI / 180 }
			const [sφ, cφ] = base.sincos(φ)
			const tφ = sφ / cφ
			const [sD, cD] = base.sincos(D)
			const [sz, cz] = base.sincos(z)
			const P = sφ * cz - cφ * sz * cD

			const lines = []
			if (typeof (cs.datesArcsDiurnes) == "undefined") { return }
			for (const d of cs.datesArcsDiurnes) {
				l = new LigneArc(d)
				coupe = false
				for (let i = 0; i < 24 * 60; i += cs.precisionArcs) {
					const H = (i - 12 * 60) / 60 * 15 * Math.PI / 180
					const aH = Math.abs(H)
					const [sH, cH] = base.sincos(H)
					const tδ = Math.tan(d[1])
					const cosH0 = -tφ * tδ
					let H0 = Math.acos(cosH0)
					if (cosH0 > 1) { H0 = -Math.PI }  //nuit polaire
					if (cosH0 <= -1) { H0 = Math.PI }  //jour polaire
					if (aH < H0) { // sun above horizon
						const Q = sD * sz * sH + (cφ * cz + sφ * sz * cD) * cH + P * tδ
						if ((Q > 0) || (cs.typeCadran == RTS)) { // sun above plane of sundial         
							const coord = coordOmbre(sH, cH, sD, cD, sz, cz, sφ, cφ, tδ, Q, H, d[1])
							if (coord.ok == true) {
								xp = coord.xo; yp = coord.yo; zp = coord.zo
								if (pointDansCadran(xp + cs.xgnomon, yp + cs.ygnomon)) {
									if (coupe) {
										if (l.points.length > 0) { lines.push(l) }
										l = new LigneArc(d); coupe = false
									}
									l.points.push(new Point(xp, yp, zp));
									xm = xp + cs.xgnomon; ym = yp + cs.ygnomon; coupe = false
								} else { coupe = true }
							} else { coupe = true }
						}
					}
				}
				if (l.points.length > 0) { lines.push(l) }
			}
			const center = new Point()
			center.x = a / P * cφ * sD
			center.y = -a / P * (sφ * sz + cφ * cz * cD)
			const aP = Math.abs(P)
			const u = a / aP
			const ψ = Math.asin(aP)
			cs.xPole = center.x; cs.yPole = center.y; cs.angleStyleSousstylaire = ψ * 180 / Math.PI;
			return {
				lines: lines,
				center: center,
				length: u,
				angle: ψ
			}
		}

		//-----------------------------------------------------------------------------------------------------
		function loadJsonFile() {
			let csl;

			const [file] = document.querySelector('input[type=file]').files;
			//console.log(file)
			Info('Loading ...')
			const reader = new FileReader();
			reader.addEventListener("load", () => {
				try { csl = JSON.parse(reader.result) }
				catch (e) { console.error("Parsing error:", e) }
				for (let k in csl) { cs[k] = csl[k] }   //  ;console.log(k,cs[k],csl[k])
				TS = TableSol(cs.year);
				if (JULIAN.LeapYearJulian(cs.year)) { nbJoursAnnee = 366; nbjoursText = "Day (1-366))" }
				else { nbJoursAnnee = 365, nbjoursText = "Day (1-365))" }
				NouveauCadran = false
				//	console.log(JSON.stringify(cs,null,2)) 
				run();
			}, false);

			if (file) {
				reader.readAsText(file);
			}

			return reader.result;
		}



		//--------------------------------------------------------------------------------------------------------
		//function saveString    Ecrit la chaine de caracteres text dans le fichier texte de nom filename 
		//saveString('mon texte','Bidon.txt');
		const link = document.createElement('a');
		link.style.display = 'none';
		document.body.appendChild(link); // Firefox workaround, see #6594
		function save(blob, filename) {
			link.href = URL.createObjectURL(blob);
			link.download = filename;
			link.click();
		}
		function saveString(text, filename) {
			save(new Blob([text], { type: 'text/plain' }), filename);
			// console.log(text)
		}

		// ---------------------------------------------------------------------------------------------------
		function eulerCsGroup() {

			if (RTSpolyhedre()) { displayFaces(polyhedre) }
			else {
				const a = new THREE.Euler((cs.incli - 90) / 180 * Math.PI, cs.decli / 180 * Math.PI, cs.rot / 180 * Math.PI, 'YXZ');
				cadranSolaireGroup.setRotationFromEuler(a)
			}

		}



		function MiseEnPlaceCadranEtGnomon(e) {
			if (e == STP) {
				cadran = cadranEquatorial.clone();
				cadran.scale.z = cs.largeur;
			} else {
				cadran = cadranBox.clone();
				cadran.scale.z = cs.epaisseur;
			}
			cadran.scale.x = cs.largeur;
			cadran.scale.y = cs.hauteur;
			cadran.scale.z = cs.epaisseur;

			cadran.receiveShadow = true;

			gnomon.position.x = cs.xgnomon;
			gnomon.position.y = cs.ygnomon;
			gnomon.position.z = (cs.hgnomon + cs.epaisseur) / 2;


			gnomon.scale.y = cs.hgnomon;
			gnomon.scale.x = cs.egnomon;
			gnomon.scale.z = cs.egnomon;
			gnomon.rotation.x = Math.PI * 0.5;
			gnomon.castShadow = true; //default is false	
			heuresGroupsRemove()

		}

		function heuresGroupsRemove() {
			cadranSolaireGroup.remove(heuresSolairesGroup);
			cadranSolaireGroup.remove(heuresLegalesGroupSA);
			cadranSolaireGroup.remove(heuresLegalesGroupWS);
			cadranSolaireGroup.remove(heuresAntiquesGroup);
			cadranSolaireGroup.remove(heuresBabyloniquesGroup);
			cadranSolaireGroup.remove(heuresItaliquesGroup);
			cadranSolaireGroup.remove(heuresSDSAgroup);
			cadranSolaireGroup.remove(heuresSDWSgroup);
			cadranSolaireGroup.remove(heuresHPSAgroup);
			cadranSolaireGroup.remove(heuresHPWSgroup);
			cadranSolaireGroup.remove(arcsDiurnesGroup);
		}
		////
		function EcrireXYZ() {
			const ht = cs.hoursTextSize
			cs.hoursTextSize = 3
			effacelisteMesh(labelAxesListeMesh, groupAxes)
			if (cs.axesXYZ == true) {
				EcrireTexte('x', 810, 0, 0, materialAxeX, groupAxes, labelAxesListeMesh, false, false);
				EcrireTexte('y', 0, 820, 0, materialAxeY, groupAxes, labelAxesListeMesh, false, false);
				EcrireTexte('z', 0, 0, 810, materialAxeZ, groupAxes, labelAxesListeMesh, false, false)
				cadranSolaireGroup.add(groupAxes)
			} else { effacelisteMesh(labelAxesListeMesh, groupAxes) }
			cs.hoursTextSize = ht
		}

		function TracerMesh(mesh) {    //maillage pour cadran 
			cadran = mesh.clone()
			cadranSolaireGroup.add(cadran)
			cadran.receiveShadow = true
			cadran.scale.x = cs.largeur;
			cadran.scale.y = cs.hauteur;
			cadran.scale.z = cs.epaisseur;
			//eulerCsGroup()
			//EcrireXYZ()
			cs.typeForme = "?"
			TracerStyle()
			PlacerLeSoleil()
			effacelisteMesh(labelAxesListeMesh, groupAxes)
			axesESZHelper.visible = cs.axesESZ
			EcrireXYZ()
			TracerHeuresEtArcs()
			//render()
			//console.log(cs)
		}


		function helpGui(g, textHelp) {
			g.domElement.addEventListener("mouseover", function () { Info(textHelp) })
			g.domElement.addEventListener("mouseout", function () { Info("") })
		}

		//---------------------------------------------------------------------------------------------------------
		function init() {

			// dat.GUI ///////////////////////////////////////////////////////////////////////////////////////parallelepiped

			const couleurMenu = "#C8FAFF"

			const gui = new GUI(
				{ width: Math.min(Math.round(window.innerWidth / 2), 280), title: "Edit sundial...", closeFolders: true });


			const guiTime = new GUI({
				container: document.getElementById('heureDate'),
				width: Math.min(Math.round(window.innerWidth / 2), 280),
				title: "Sundial time"
			})
			guiTime.$title.style.color = 'yellow'

			const guiTimehsol = guiTime.add(cs, "hsol", 0, 24, 0.01)
				.name("Hour  (0-24)")
				.onChange(function () { PlacerLeSoleil() }).listen();
			helpGui(guiTimehsol, 'Decimal hour')


			const guiTimeday = guiTime.add(cs, "dayofYear", 1, nbJoursAnnee, 1)
				.name(nbjoursText)
				.onChange(function () {
					PlacerLeSoleil();
					if (cs.typeCadran == ANL) TracerStyle()
					if (cs.typeCadran == STP) {
						cs.sais = ((cs.dayofYear >= TS.jdecSunMax) && (cs.dayofYear < TS.jdecSunMin))  //True en été et automne
						TracerStyle()
					}
				});
			helpGui(guiTimeday, 'Day of the year')

			const guiTimeyear = guiTime.add(cs, "year")
				.name("Year")
				.onChange(function (v) {
					if (JULIAN.LeapYearJulian(v)) {
						nbJoursAnnee = 366
						nbjoursText = "Day (1-366))"
					} else {
						nbJoursAnnee = 365
						nbjoursText = "Day (1-365))"
					}
					console.log(nbJoursAnnee)
					guiTimeday.name(nbjoursText)
					guiTimeday.max(nbJoursAnnee)
					guiTimeday.updateDisplay()
				})
				.onFinishChange(function () {
					TS = TableSol(cs.year)
					TracerHeuresEtArcs()
				})
				.listen()
			helpGui(guiTimeyear, 'leap years taken into account')


			const Vsun = {
				"0": 0,
				"1 sec. /sec": 1,
				"1 min  /sec": 60,
				"10 min /sec": 600,
				"20 min /sec": 1200,
				"30 min /sec": 1800,
				"1 hour /sec": 3600
				//	"1 day  /sec": 3600*24
			}
			function myTimerSun() {
				cs.hsol += cs.vrotSun / 360000;
				//cs.hsol = Math.round(cs.hsol * 1000000) / 1000000
				if (cs.hsol > 24) { cs.hsol = 0; cs.dayofYear += 1 };
				if (cs.dayofYear > nbJoursAnnee) { cs.dayofYear = 1 }
				PlacerLeSoleil()
			}
			let temporisation = null;
			function RotationSoleil(e) {
				window.clearInterval(temporisation);
				if (e > 0) { temporisation = window.setInterval(myTimerSun, 10) }; //    1/100 sec
			}

			const guiRotSun = guiTime.add(cs, "vrotSun", Vsun)
				.name('Rotation of the sun')
				.onChange(function (e) { RotationSoleil(e) });
			helpGui(guiRotSun, 'Speed of rotation of the sun around the dial <br> 0: stationary sun   1 sec/sec: real speed <br> 1 min/sec: speedx60  10 min/sec: speedx600 <br> 20 min/sec: speedx120   30 min/sec: speedx1800 <br> 1 hour/sec: speedx3600 <br>')


			function TracerCadranRTS(v) {
				// const plyloader = new PLYLoader();
				// const objloader= new OBJLoader()

				function TracerSolide() {
					if (NouveauCadran == true) {
						cs.decli = 0; cs.incli = 90; cs.rot = 0; cs.xgnomon = 0
						cs.epaisseur = 30; cs.largeur = 600; cs.hauteur = 400
						if (cs.typeForme == "cone") {
							cs.epaisseur = 400; cs.largeur = 400; cs.hauteur = 400;
							cs.ygnomon = 120; cs.zgnomon = 140
						}
						if (cs.typeForme == "cylinder") {
							cs.epaisseur = 100; cs.largeur = 100; cs.hauteur = 400
							cs.ygnomon = 120; cs.zgnomon = 150
						}
						if (cs.typeForme == "sphere") {
							cs.epaisseur = 300; cs.largeur = 300; cs.hauteur = 300
							cs.ygnomon = 150; cs.zgnomon = 160
						}
					}

					cadran.scale.x = cs.largeur;
					cadran.scale.y = cs.hauteur;
					cadran.scale.z = cs.epaisseur
					cadranSolaireGroup.add(cadran);
					eulerCsGroup()
					//TracerStyle()
					TracerHeuresEtArcs()
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey);
					//render()
					//console.log(NouveauCadran,cs.decli)
				}
				function TracerCadranEquatorial() {
					cadranSolaireGroup.add(cadran);
					// folderDimensionsSundial.show()
					// folderOrientationSundial.show()
					//axeMondeGroup.add(cadran)
					if (NouveauCadran == true) {
						cs.epaisseur = 300; cs.hauteur = 300; cs.largeur = 300
						cs.xgnomon = 0; cs.ygnomon = 0; cs.zgnomon = 0
						cs.decli = 0; cs.incli = cs.lati
					}
					cadran.scale.x = cs.largeur;
					cadran.scale.y = cs.hauteur;
					cadran.scale.z = cs.epaisseur
					eulerCsGroup()
					//TracerStyle()
					TracerHeuresEtArcs()
					//render()
				}

				function TracerCadranScaphe() {
					//materialCS.side = THREE.doubleSide
					cadranSolaireGroup.add(cadran);
					if (NouveauCadran == true) {
						cs.epaisseur = 300; cs.hauteur = 300; cs.largeur = 300
						cs.xgnomon = 0; cs.ygnomon = 0; cs.zgnomon = 0
						cs.decli = 0; cs.incli = cs.lati
					}
					cadran.scale.x = cs.largeur;
					cadran.scale.y = cs.hauteur;
					cadran.scale.z = cs.epaisseur;
					eulerCsGroup()
					TracerStyle()
					TracerHeuresEtArcs()
					//render()
				}

				function TracerFichier() {
					var fileInput = document.createElement('input');

					fileInput.type = 'file';
					fileInput.multiple = false;
					fileInput.accept = ".ply,.obj"
					fileInput.addEventListener('change', function () {
						const reader = new FileReader();
						const file = fileInput.files[0]
						const NF = file.name.toLowerCase()
						reader.readAsDataURL(file)
						reader.addEventListener("load", () => {
							cs.dataURL = reader.result
							if (NF.lastIndexOf('.obj') > 0) {
								cs.typedataURL = '.obj'
								objloader.load(cs.dataURL, function (Lucymesh) { TracerMesh(Lucymesh) })
							}
							if (NF.lastIndexOf('.ply') > 0) {
								cs.typedataURL = '.ply'
								plyloader.load(cs.dataURL, function (LucyGeom) {
									const Lucymesh = new THREE.Mesh(LucyGeom, materialCS)
									Lucymesh.geometry.computeVertexNormals()
									TracerMesh(Lucymesh)
								})
							}
							if (NouveauCadran == true) {
								cs.xgnomon = 0; cs.ygnomon = 100; cs.zgnomon = 100
								cs.epaisseur = 1; cs.hauteur = 1; cs.largeur = 1
								cs.decli = 0; cs.incli = 90; cs.rot = 0
							}
							eulerCsGroup()
							EcrireXYZ()
							cs.typeForme = "?"
						}
							, false);
					});
					document.body.appendChild(fileInput);
					fileInput.click();
					cs.typeForme = '?'
					TracerHeuresEtArcs()
				}

				function TracerCadranParam() {
					//materialCS.side = THREE.DoubleSide
					gParam.show()
					if (NouveauCadran == true) {
						cs.epaisseur = 10; cs.hauteur = 300; cs.largeur = 300
						cs.xgnomon = 0; cs.ygnomon = 0; cs.zgnomon = 50
						cs.decli = 0; cs.incli = 90
						NouveauCadran = false
					}

					uMin = cs.gParam_uMin; uMax = cs.gParam_uMax
					vMin = cs.gParam_vMin; vMax = cs.gParam_vMax
					uRange = uMax - uMin;
					vRange = vMax - vMin;

					if (cs.zfxy != "") {
						cs.gParam_zText = Parametrer(cs.zfxy)
						cs.zfxy = ""
						gParam_zText.setValue(cs.gParam_zText)
					}

					function Parametrer(fText) {
						fText = fText.replace(/A/g, cs.gParam_a.toString());
						fText = fText.replace(/B/g, cs.gParam_b.toString());
						fText = fText.replace(/C/g, cs.gParam_c.toString());
						fText = fText.replace(/D/g, cs.gParam_d.toString());
						fText = fText.replace(/x/g, "u");
						fText = fText.replace(/y/g, "v");
						fText = fText.replace(/eup/g, "exp");
						fText = fText.replace(/mau/g, "max");
						return (fText)
					}

					const sx = Parametrer(cs.gParam_xText)
					try { xFunc = Parser.parse(sx).toJSFunction(['u', 'v']) }
					catch (err1) { alert("incorrect x formula " + err1.message) }
					const sy = Parametrer(cs.gParam_yText)
					try { yFunc = Parser.parse(sy).toJSFunction(['u', 'v']) }
					catch (err2) { alert("incorrect y formula") + err2.message }
					const sz = Parametrer(cs.gParam_zText)
					try { zFunc = Parser.parse(sz).toJSFunction(['u', 'v']) }
					catch (err3) { alert("incorrect z formula" + err3.message) }

					meshFunction = (u0, v0, target) =>   // u0 et vo entre 0 et 1
					{
						const u = uRange * u0 + uMin;
						const v = vRange * v0 + vMin;       // u entre umin et umax   v entre vmin et vmax
						const x = xFunc(u, v);
						const y = yFunc(u, v);
						const z = zFunc(u, v);
						target.set(x, y, z)
					};

					const geometryCSParam = new ParametricGeometry(meshFunction, cs.gParam_segments, cs.gParam_segments);
					const cadranParam = new THREE.Mesh(geometryCSParam, materialCS)

					cadranParam.castShadow = true
					cadranParam.receiveShadow = true
					cadran = cadranParam.clone()
					cadran.scale.x = cs.largeur;
					cadran.scale.y = cs.hauteur;
					cadran.scale.z = cs.epaisseur
					cadranSolaireGroup.add(cadran);
					eulerCsGroup()
					TracerHeuresEtArcs()


					gTypeCadran.hide()
					gtypeForme.hide()
				}

				function TracerCadranPolyedrique() {
					cs.axesXYZ = false
					numFace = ""
					if (NouveauCadran == true) {
						cs.incli = 90; cs.decli = 0; cs.rot = 0
						const a = new THREE.Euler((cs.incli - 90) / 180 * Math.PI, cs.decli / 180 * Math.PI, cs.rot / 180 * Math.PI, 'YXZ');
						cadranSolaireGroup.setRotationFromEuler(a)  // important! Remise à plat du polyedre!
						polyhedre = POLYHEDRA.Dodecahedron
					}
					if (NouveauCadran == false) {   // apres lecture dans un fichier json
						for (var arg in POLYHEDRA) {
							if (POLYHEDRA[arg].name == cs.typePolyedre) {
								const a = arg
								polyhedre = POLYHEDRA[a]
								continue
							}
						}
					}
					if (cs.uniform == true) {
						cs.largeur = cs.rayonPolyedre
						cs.hauteur = cs.rayonPolyedre
						cs.epaisseur = cs.rayonPolyedre
					}
					guiSectionPoly.title("POLYEDRA : " + polyhedre.name)
					cs.typePolyedre = polyhedre.name
					nbFaces = polyhedre.face.length
					folderGnomon.hide()
					//folderDimensionsSundial.hide()
					heuresGroupsRemove()

					initPol()

					gTypeCadran.hide()
					gtypeForme.hide()
				}

				gParam.hide()
				Info("")

				cadranSolaireGroup.clear()
				cadranSolaireGroup.add(axeX)
				cadranSolaireGroup.add(axeY)
				cadranSolaireGroup.add(axeZ)
				//materialCS.side = THREE.FrontSide
				folderDevise.show()
				folderGnomon.show()
				folderDimensionsSundial.show()
				voirSectionPoly(false)
				//materialCS.map = null
				//materialCS.emissiveMap = null
				//	materialCS.wrapS = materialCS.wrapT = THREE.RepeatWrapping;
				//	materialCS.colorSpace = THREE.SRGBColorSpace;
				materialCS.needsUpdate = true
				cs.name = 'none'

				if (v == "parallelepiped") { cadran = cadranBox.clone(); TracerSolide() }//; cs.epaisseur = cs.largeur }
				if (v == "cylinder") { cadran = cadranCyl.clone(); TracerSolide() }//; cs.epaisseur = cs.largeur }
				if (v == "cone") { cadran = cadranCone.clone(); TracerSolide() }//; cs.epaisseur = cs.largeur }
				if (v == "sphere") { cadran = cadranSph.clone(); TracerSolide() }//; cs.epaisseur = cs.largeur; cs.hauteur = cs.largeur }
				if (v == "equatorial") { cadran = cadranEquatorial.clone(); TracerCadranEquatorial() }
				if (v == "scaphe") { cadran = cadranScaphe.clone(); TracerCadranScaphe() }
				if (v == "file PLY, OBJ...") { TracerFichier() }
				if (v == "parametric") { TracerCadranParam() }
				if (v == "polyedric") { folderDevise.hide(); TracerCadranPolyedrique() };/* gTypeCadran.hide();gtypeForme.hide()*/

				cadran.receiveShadow = true
				cadran.castShadow = true
				gnomon.visible = false
				eulerCsGroup()
				PlacerLeSoleil()
				//render()
				EcrireXYZ()

				// gTypeCadran.hide()
				// gtypeForme.hide()

			}



			function initMenu(e) {
				Info("")
				gParam.hide()
				cadranSolaireGroup.clear();
				polyhedre = undefined
				// cadran = cadranBox.clone()  // YM: dans MiseEnPlaceCadranEtGnomon(e)
				//for (var k in cso) { cs[k] = cso[k] }
				if (NouveauCadran == true) {
					cs.largeur = 600
					cs.hauteur = 400
					cs.epaisseur = 15
					cs.decli = 0
					cs.incli = 90
					cs.hgnomon = 50
					cs.egnomon = 1
					cs.xgnomon = 0
					cs.ygnomon = 100
					cs.zgnomon = 70
					cs.rot = 0
					cs.hoursTextSize = 0.5
					cs.dataURL = ""
					cs.devise = "Carpe diem"
					cs.positionDevisex = -280,
						cs.positionDevisey = -180
					cs.deviseSize = 1
					if (cs.typeCadran == ANL) { cs.incli = 0; cs.ygnomon = -40 }
					if (cs.typeCadran == STP) { cs.devise = "" }//;textureCS("")}

					//cs.typeCadran=SP
					//folderAnalem.hide();
				}

				MiseEnPlaceCadranEtGnomon(e)

				cadranSolaireGroup.add(cadran);
				folderDimensionsSundial.show()
				folderOrientationSundial.show()
				folderGnomon.show()
				gtypeForme.hide()
				if (cs.typeForme == "parametric") { gParam.show() } else { gParam.hide() }
				//voirSectionPoly(RTSpolyhedre())
				folderDevise.show(!RTSpolyhedre())
				zPosController.disable()
				ctlRot.disable()
				eulerCsGroup()
				PlacerLaTerre()
				PlacerLeSoleil()
				groupAxes.add(axeX)
				groupAxes.add(axeY)
				groupAxes.add(axeZ)
				cadranSolaireGroup.add(groupAxes)
				EcrireXYZ()
				folderSTP.hide();
				ctlEpais.enable();
				folderGnomonPosition.show();


				if (e == SP) {
					folderGnomonBifilaireVertical.hide();
					folderGnomonBifilaireGen.hide();
					folderAnalem.hide();
					cadranSolaireGroup.remove(analemGroup);
					ctlIncli.enable();
					folderGnomonClassic.show();
					folderHours.show();
					folderArcs.show();
					cs.typeCadran = SP;
					cs.vgnomon = true;
					gnomon.position.z = (cs.hgnomon + cs.epaisseur) / 2
					gnomon.visible = true
					TracerHeuresEtArcs();
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey);
				};
				if (e == BF) {
					folderGnomonClassic.hide();
					folderGnomonBifilaireGen.hide();
					folderAnalem.hide();
					cadranSolaireGroup.remove(analemGroup);
					ctlIncli.setValue(90);
					cs.incli = 90;
					ctlIncli.disable();
					folderGnomonBifilaireVertical.show()
					folderHours.show();
					folderArcs.show();
					cs.typeCadran = BF;
					calculg1g2k1k2()
					TracerHeuresEtArcs();
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey);
				};
				if (e == BFG) {
					folderGnomonClassic.hide();
					folderGnomonBifilaireVertical.hide();
					folderAnalem.hide();
					cadranSolaireGroup.remove(analemGroup);
					ctlIncli.enable();
					cs.typeCadran = BFG;
					folderGnomonBifilaireGen.show();
					folderHours.show();
					folderArcs.show();
					TracerHeuresEtArcs()
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey);
				}

				if (e == ANL) {
					folderGnomonBifilaireVertical.hide();
					folderGnomonBifilaireGen.hide();
					folderGnomonClassic.hide();
					folderHours.hide();
					folderArcs.hide();
					//gnomon.visible = false;
					ctlIncli.enable();
					//cs.incli=0;
					eulerCsGroup();
					folderAnalem.show();
					TracerHeuresEtArcs();
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey);
				}

				if (e == STP) {
					folderGnomonBifilaireVertical.hide();
					folderGnomonBifilaireGen.hide();
					folderGnomonClassic.hide();
					folderHours.hide();
					folderArcs.hide();
					folderAnalem.hide();

					folderOrientationSundial.hide();
					folderGnomonPosition.hide();
					ctlEpais.hide();

					folderSTP.show();
					TracerHeuresEtArcs();
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey);
				}

				if (e == RTS) {
					folderGnomonBifilaireVertical.hide();
					folderGnomonBifilaireGen.hide();
					folderAnalem.hide();
					folderGnomonClassic.hide()
					cadranSolaireGroup.remove(analemGroup);
					ctlIncli.enable();
					folderHours.show();
					folderArcs.show();
					cs.typeCadran = RTS;
					//if(NouveauCadran){initMenu}
					TracerCadranRTS(cs.typeForme)
					//TracerHeuresEtArcs();
					gtypeForme.show()
					zPosController.enable()
					ctlRot.enable()
					if (cs.typeForme == "parametric") { gParam.show() } else { gParam.hide() }
				}
				//console.log('Fin InitMenu')
			}


			//const sp = "☼ "
			const sp = ""
			gui.$title.style.color = 'yellow'


			const gTypeCadran = gui.add(cs, "typeCadran", [SP, BF, BFG, ANL, STP, RTS]).name("Type of sundial") ///+++
				.onChange(function (e) {
					NouveauCadran = true
					initMenu(e)
					if (e !== RTS) { gParam.hide(); voirSectionPoly(false) }
				});

			const gtypeForme = gui.add(cs, "typeForme", ["parallelepiped", "cylinder", "cone", "sphere", "equatorial", "scaphe", "file PLY, OBJ...", "parametric", "polyedric"])
				.name("Form of sundial") ///+++
				.onFinishChange(function (v) { TracerCadranRTS(v) })
				.listen()




			const Button2D = {
				function2D() {
					let w; // window
					cs.unitSVG = "auto"
					construireFichierSVG()
					w = window.open()
					w.name = cs.nameFile
					w.document.write(`					
					<!DOCTYPE html>
					<html lang="en">
  			    	<head>					
					<meta charset="utf-8" />
	                <title>CadsolOnLine 2D ${cs.nameFile}</title>
					</head>
					<body>
					`)
					w.document.write(SVGtext)
					w.document.write(`
					</body>
					</html>
	                `)
					w.document.close()
					if (cs.typeForme == "polyedric") { VoirPoly2D = false; TracerHeuresEtArcs() }
					//console.log(SVGtext)
				}
			}
			const guiButton2D = gui.add(Button2D, 'function2D').name('2D View');
			helpGui(guiButton2D, 'Projection on the plane xOy')

			const ButtonParam = {
				functionParam() {
					let w; // window
					w = window.open()
					w.name = cs.nameFile
				    w.document.write(HTLM(cs))
					//w.document.write(JSON.stringify(cs, null, 2))
					w.document.close()
					if (cs.typeForme == "polyedric") { VoirPoly2D = false; TracerHeuresEtArcs() }
					//console.log(SVGtext)
				}
			}
			const guiButtonParam = gui.add(ButtonParam, 'functionParam').name('Parameters');
			helpGui(guiButtonParam, 'Parameters')




			//// SURFACE PARAMETREE
			var gParam, gParam_xText, gParam_yText, gParam_zText,
				gParam_uMin, gParam_uMax, gParam_vMin, gParam_vMax,
				gParam_a, gParam_b, gParam_c, gParam_d,
				gParam_segments;

			gParam = gui.addFolder(sp + "Parametric functions ")


			gParam_xText = gParam.add(cs, 'gParam_xText').name('x = f(u,v)')
				.onFinishChange(function () { TracerCadranRTS("parametric") })

			gParam_yText = gParam.add(cs, 'gParam_yText').name('y = f(u,v)')
				.onFinishChange(function (v) { TracerCadranRTS("parametric") })

			gParam_zText = gParam.add(cs, 'gParam_zText').name('z = f(u,v)')
				.onFinishChange(function (v) { TracerCadranRTS("parametric") })
				.listen()

			gParam_uMin = gParam.add(cs, 'gParam_uMin').name('u Minimum = ')
				.onFinishChange(() => { TracerCadranRTS("parametric") })
			gParam_uMax = gParam.add(cs, 'gParam_uMax').name('u Maximum = ')
				.onFinishChange(() => { TracerCadranRTS("parametric") })
			gParam_vMin = gParam.add(cs, 'gParam_vMin').name('v Minimum = ')
				.onFinishChange(() => { TracerCadranRTS("parametric") })
			gParam_vMax = gParam.add(cs, 'gParam_vMax').name('v Maximum = ')
				.onFinishChange(() => { TracerCadranRTS("parametric") })


			//let a=1,b=1,c=1,d=1
			gParam_a = gParam.add(cs, 'gParam_a').min(-100).max(100).step(0.01).name('const A → ')
				.onFinishChange(() => { TracerCadranRTS("parametric") })
			gParam_b = gParam.add(cs, 'gParam_b').min(-100).max(100).step(0.01).name('const B →')
				.onFinishChange(() => { TracerCadranRTS("parametric") })
			gParam_c = gParam.add(cs, 'gParam_c').min(-100).max(100).step(0.01).name('const C →')
				.onFinishChange(() => { TracerCadranRTS("parametric") })
			gParam_d = gParam.add(cs, 'gParam_d').min(-100).max(100).step(0.01).name('const D →')
				.onFinishChange(() => { TracerCadranRTS("parametric") })
			helpGui(gParam_a, 'A,B,C,D are constants')

			gParam_segments = gParam.add(cs, 'gParam_segments', 25, 250, 1).name('Subdivisions = ')
				.onFinishChange(() => { TracerCadranRTS("parametric") })

			const helpParam = 'Syntax: + - * / % ^ ( )<br>functions: sin cos tan asin acos atan <br> sqrt log exp abs ceil floor round PI E'
			helpGui(gParam_xText, helpParam)
			helpGui(gParam_yText, helpParam)
			helpGui(gParam_zText, helpParam)

			InitGuiPolyedres(gui)
			voirSectionPoly(false)


			//// GEOLOCALISATION
			const folderGeoSundial = gui.addFolder(sp + "Geolocation")
			//folderGeoSundial.domElement.addEventListener
			folderGeoSundial.add(cs, "lati", -90, 90, 0.001)
				.name("Latitude")
				.onChange(() => { PlacerLaTerre() })
				.onFinishChange(() => {
					orienterAxedumonde();
					PlacerLaTerre(); eulerCsGroup()
					PlacerLeSoleil(); TracerHeuresEtArcs(); TracerStyle()
					if ((cs.typeCadran == RTS) && (cs.typeForme == "equatorial")) { TracerCadranRTS("equatorial") }
					if ((cs.typeCadran == RTS) && (cs.typeForme == "scaphe")) { TracerCadranRTS("scaphe") }
					if (RTSpolyhedre()) { tracerTouteslesfaces() }
					if (cs.sphereArmilaire) { effacerSphereArmilaire(); tracerSphereArmilaire() }
				})
				.listen();
			folderGeoSundial.add(cs, "longi", -180, 180, 0.001)
				.name("Longitude")
				.onChange(() => {
					PlacerLaTerre()
					cs.offset_sec = Math.trunc(cs.longi / 15) * 3600
				})
				.onFinishChange(() => {
					orienterAxedumonde();
					PlacerLaTerre(); eulerCsGroup()
					PlacerLeSoleil(); TracerHeuresEtArcs(); TracerStyle()
					if (RTSpolyhedre()) { tracerTouteslesfaces() }
				})
				.listen();



			const folderViewParam = {
				functionViewMap() {
					if (cs.adresse.length > 0) {
						RechercheParAdresse(cs.adresse);
						TracerHeuresEtArcs();
						orienterAxedumonde();
						PlacerLaTerre();
						TracerHeuresEtArcs()
						window.open(cs.urlOpenStreet, "OSM", "toolbar=yes,scrollbars=yes,resizable=yes,top=100,left=100,width=400,height=400")
					}
				}
			}
			folderGeoSundial.add(folderViewParam, "functionViewMap")
				.name('Seek by adress')

			folderGeoSundial.add(cs, "adresse")
				.name("postal adress")
				.onFinishChange(() => {
					if (cs.adresse.length > 0) {

						window.open(cs.urlOpenStreet, "OSM", "toolbar=yes,scrollbars=yes,resizable=yes,top=100,left=100,width=400,height=400")
						RechercheParAdresse(cs.adresse);
						TracerHeuresEtArcs();
						orienterAxedumonde();
						PlacerLaTerre();
						TracerHeuresEtArcs()
					}
				})

			folderGeoSundial.add(cs, "timezone")
				.name("Time zone")
				.listen();

			folderGeoSundial.add(cs, "offset_sec", -43200, 43200, 60)
				.name("offset from UTC (sec)")
				.onFinishChange(function (v) {
					cs.offset_sec = v;
					TracerHeuresEtArcs()
				})
				.listen();
			const ofStr = folderGeoSundial.add(cs, "offset_string")
				.name("+/- HHMM")
				.listen()
			ofStr.disable()
			//console.log(cs)
			folderGeoSundial.add(cs, "autoLocation")
				.name("auto")
				.onFinishChange(function (v) {
					if (v) {
						getLocation()
						TracerHeuresEtArcs(); orienterAxedumonde();
						PlacerLaTerre()
					}
				})

			//   folderGeoSundial.add(cs,"offset_string") 
			//        .name(" offset (HHMM)");
			//   folderGeoSundial.add(cs,"now_in_dst") 
			//        .name("summer time (H)");

			const folderSundial = gui.addFolder(sp + 'Geometry ');


			//// ORIENTATION	

			const folderOrientationSundial = folderSundial.addFolder("Orientation...");
			const ctlDecli = folderOrientationSundial.add(cs, "decli", -180, 180, 0.1)
				.name("Declinaison °")
				.onChange(() => { eulerCsGroup()/*;TracerHeuresEtArcs;TracerStyle()*/ })
				.onFinishChange(() => {
					eulerCsGroup(); TracerHeuresEtArcs(); TracerStyle()
					if (RTSpolyhedre()) { tracerTouteslesfaces() }
				})

			const ctlIncli = folderOrientationSundial.add(cs, "incli", -180, 180, 0.1)
				.name("Inclinaison °")
				.onChange(() => { eulerCsGroup()/*;TracerHeuresEtArcs();TracerStyle()*/ })
				.onFinishChange(() => {
					eulerCsGroup(); TracerHeuresEtArcs(); TracerStyle()
					if (RTSpolyhedre()) { tracerTouteslesfaces() }
				})
				.listen()
			const ctlRot = folderOrientationSundial.add(cs, "rot", -180, 180, 0.1)
				.name("Rotation °")
				.onChange(function (v) { eulerCsGroup() })
				.onFinishChange(function () {
					eulerCsGroup(); TracerHeuresEtArcs(); TracerStyle()
					if (RTSpolyhedre()) { tracerTouteslesfaces() }
				})
				.listen()

			//// DIMENSIONS
			const folderDimensionsSundial = folderSundial.addFolder("Dimensions...");
			folderDimensionsSundial.add(cs, "largeur", 1, 1000, 0.1)
				.name("Width")
				.onChange(() => {
					cadran.scale.x = cs.largeur; cs.uniform = false
					meshDevise.position.x = -cs.largeur / 2 * 0.9
					cs.positionDevisex = meshDevise.position.x
				})
				.onFinishChange(function () { TracerHeuresEtArcs(); if (RTSpolyhedre()) { tracerTouteslesfaces() } })
				.listen()
			folderDimensionsSundial.add(cs, "hauteur", 1, 1000, 0.1)
				.name("Height")
				.onChange(function (v) {
					cs.hauteur = v; cadran.scale.y = cs.hauteur; cs.uniform = false
					meshDevise.position.y = -cs.hauteur / 2 * 0.9;
					cs.positionDevisey = meshDevise.position.y
					PlacerLaTerre()
				})
				.onFinishChange(function () { TracerHeuresEtArcs(); if (RTSpolyhedre()) { tracerTouteslesfaces() } })
				.listen()
			const ctlEpais = folderDimensionsSundial.add(cs, "epaisseur", 1, 1000, 0.1)
				.name("Depth")
				.onChange(function (v) {
					cs.epaisseur = v;
					cadran.scale.z = cs.epaisseur; cs.uniform = false
					meshDevise.position.z = cs.epaisseur / 2;
					gnomon.position.z = (cs.hgnomon + cs.epaisseur) / 2
				})
				.onFinishChange(function () { TracerHeuresEtArcs(); if (RTSpolyhedre()) { tracerTouteslesfaces() } })
				.listen();

			//// STYLE

			const folderGnomon = folderSundial.addFolder('Shadow by ...');

			//// ANALEMMATIQUE  +++

			const folderAnalem = folderGnomon.addFolder("Gnomon");
			const xIncANL = folderAnalem.add(cs, "xdirect", -89, 89, 0.1)
				.name("← → °")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			helpGui(xIncANL, "Gnomon/center tilt along the x axis");
			const yIncANL = folderAnalem.add(cs, "ydirect", -89, 89, 0.1)
				.name("↑ ↓ °")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			helpGui(yIncANL, "Gnomon/center tilt along the y axis");
			const lgGnoANL = folderAnalem.add(cs, "Hanalem", 1, 1000, 1)
				.name("Length")
				.onChange(function () { TracerStyle() });
			helpGui(lgGnoANL, "Length of the gnomon");
			const rayANL = folderAnalem.add(cs, "Ranalem", 10, 500, 1)
				.name("Base radius")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			helpGui(rayANL, "Radius of the projected auxiliary circle");
			folderAnalem.addColor(cs, "colorAnalem")
				.name("Color")
				.onChange(function (e) {
					materialAnalem.color = new THREE.Color(e);
					cs.colorAnalem = materialAnalem.color.getStyle()
				});
			folderAnalem.add(cs, "textSizeANL", 0, 5, 0.1)
				.name("Font size")
				.onFinishChange(function () { TracerHeuresEtArcs() });
			const dtANL = folderAnalem.add(cs, "dateAnalem", 1, 31, 1)
				.name("Date (1..31)")
				.onFinishChange(function () { TracerHeuresEtArcs() });
			helpGui(dtANL, "Day number for the graduation of the date scale");
			folderAnalem.add(cs, "subAnalem", { "1 heure": 1, "30 min": 0.5, "15 min": 0.25 })
				.name('Subdivisions')
				.onChange(function () { TracerHeuresEtArcs() });
			const centANL = folderAnalem.add(cs, "Canalem")
				.name("Central proj.")
				.onChange(function () {
					if (cs.Canalem) distAnalem.enable(); else distAnalem.disable();
					TracerStyle();
					TracerHeuresEtArcs()
				});
			helpGui(centANL, "Use of the central projection<br>(the small sphere)");
			const distAnalem = folderAnalem.add(cs, "zdirect", -300, 300, 0.1)
				.name("Center dist. [%]")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			helpGui(distAnalem, "Distance of the projection center<br>(percentage of base radius)");
			if (!cs.Canalem) distAnalem.disable();

			//// STYLE PROFILE

			const folderSTP = folderGnomon.addFolder("Gnomon");
			const aSTP = folderSTP.add(cs, "a", -10, 10, 0.1)
				.name("angle °")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			helpGui(aSTP, "Angle for EoT = 0");
			const RmaxSTP = folderSTP.add(cs, "Rmax", 5, 100, 1)
				.name("Rmax style %")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() });
			helpGui(RmaxSTP, "Maximum radius of the style");
			// const saisSTP = folderSTP.add(cs, "sais")
			// 	.name("Summer and Autumn")
			// 	.onChange(function () {
			// 		TracerStyle();
			// 	});
			// helpGui(saisSTP, "Style versus season");
			// const saisSTPSA = folderSTP.add(cs, "saisSA")
			// 	.name("Summer and Autumn")
			// 	.onChange(function () {
			// 		TracerStyle();
			// 	});
			// //helpGui(saisSTPWS, "Style SA");
			// const saisSTPWS = folderSTP.add(cs, "saisWS")
			// 	.name("Winter and spring")
			// 	.onChange(function () {
			// 		TracerStyle();
			// 	});
			//helpGui(saisSTP, "Style versus season");
			const appxSTP = folderSTP.add(cs, "appx")
				.name("Approximate")
				.onChange(function () {
					TracerStyle();
				});
			helpGui(appxSTP, "Approximate shape of the style");
			const rebSTP = folderSTP.add(cs, "support")
				.name("mount of the style")
				.onChange(function () {
					TracerStyle();
				});
			helpGui(rebSTP, "Set/remove the mount of the style");
			// const rebSTP = folderSTP.add(cs, "reb")
			// 	.name("Reversal")
			// 	.onChange(function () {
			// 		TracerStyle();
			// 	});
			// helpGui(rebSTP, "Set/remove reversal part");
			folderSTP.addColor(cs, "colorAnalem")
				.name("Color")
				.onChange(function (e) {
					materialAnalem.color = new THREE.Color(e);
				});
			folderSTP.add(cs, "textSizeANL", 0, 5, 0.1)
				.name("Font size")
				.onFinishChange(function () { TracerHeuresEtArcs() });
			folderSTP.add(cs, "subAnalem", { "1 heure": 1, "30 min": 0.5, "15 min": 0.25 })
				.name('Subdivisions')
				.onChange(function () { TracerHeuresEtArcs() });


			// / Style droit ou polaire
			const folderGnomonClassic = folderGnomon.addFolder('Straight or polar style...');
			folderGnomonClassic.add(cs, "hgnomon", 1, 1000, 0.1)
				.name("Length straight style")
				.onChange(function (e) {
					gnomon.scale.y = cs.hgnomon;
					gnomon.position.z = (cs.hgnomon + cs.epaisseur) / 2
					//eulerCsGroup(); TracerHeuresEtArcs(); 
					TracerStyle();
				})
				.onFinishChange(function () { eulerCsGroup(); TracerHeuresEtArcs(); TracerStyle() })
			folderGnomonClassic.add(cs, "vgnomon")
				.name("straight style visible")
				.onChange(function (e) {
					gnomon.visible = e
					TracerStyle();
				})
			folderGnomonClassic.add(cs, "vstyle")
				.name("polar style visible")
				.onChange(function (e) {
					//TracerHeuresEtArcs()				    
					stylePolaire.visible = e; stylePlan.visible = e; styleBord.visible = e
					FinStyle.visible = e; BoutStyle.visible = e
					TracerStyle();
				})
			folderGnomonClassic.add(cs, "vsousstyle")
				.name("under style visible")
				.onChange(function (e) {
					//TracerHeuresEtArcs()			    
					sousStylaire.visible = e
					TracerStyle();
				})


			// filaire vertical

			const folderGnomonBifilaireVertical = folderGnomon.addFolder('Wires...');
			folderGnomonBifilaireVertical.add(cs, "anglefilHorizontal", 0, 180, 0.1)
				.name("angle  A")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireVertical.add(cs, "anglefilVertical", 0, 180, 0.1)
				.name("angle  B")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireVertical.add(cs, "hfilHorizontal", 1, 500, 0.1)
				.name("height  A")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireVertical.add(cs, "hfilVertical", 1, 500, 0.1)
				.name("height  B")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })




			// filaire generalised	        

			const folderGnomonBifilaireGen = folderGnomon.addFolder('Wires...');

			folderGnomonBifilaireGen.add(cs, "anglefilHorizontal", 0, 180, 0.1)
				.name("angle  A")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "anglefilVertical", 0, 180, 0.1)
				.name("angle  B")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "hA1", 0, 1000, 0.1)
				.name("height A1")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "hA2", 0, 1000, 0.1)
				.name("height A2")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "hB1", 0, 1000, 0.1)
				.name("height B1")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })
			folderGnomonBifilaireGen.add(cs, "hB2", 0, 1000, 0.1)
				.name("height B2")
				.onChange(function () { TracerStyle() })
				.onFinishChange(function () { TracerHeuresEtArcs() })


			const folderGnomonPosition = folderGnomon.addFolder('Position ...');

			folderGnomonPosition.add(cs, "xgnomon", -1000, 1000, 0.1)
				.name("← xOx →")
				.onChange(function () {
					gnomon.position.x = cs.xgnomon;
					TracerStyle()
					gnomon.visible = cs.vgnomon && (cs.typeCadran == SP)//||(cs.typeCadran == RTS))		
				})
				.onFinishChange(function () {
					TracerHeuresEtArcs()
				})
				.listen()
			folderGnomonPosition.add(cs, "ygnomon", -1000, 1000, 0.1)
				.name("↑  yOy  ↓")
				.onChange(function () {
					gnomon.position.y = cs.ygnomon;
					TracerStyle()
					gnomon.visible = cs.vgnomon && (cs.typeCadran == SP)//||(cs.typeCadran == RTS))
				})
				.onFinishChange(function () {
					TracerHeuresEtArcs()
				})
				.listen()
			const zPosController = folderGnomonPosition.add(cs, "zgnomon", -1000, 1000, 0.1)
				.name("/  zOz  /")
				.onChange(function () {
					TracerStyle()
				})
				.onFinishChange(function () {
					TracerHeuresEtArcs()
				})
				.listen()

			folderGnomon.add(cs, "egnomon", 0.1, 5, 0.01)
				.name("Thickness")
				.onChange(function () {
					TracerStyle()
				})
				.onFinishChange(function () {
					gnomon.scale.x = cs.egnomon;
					gnomon.scale.z = cs.egnomon;
					if (RTSpolyhedre()) { displayFaces(polyhedre); tracerTouteslesfaces() }
					TracerHeuresEtArcs()
				});






			//// COLOR             
			const folderColorsSundial = gui.addFolder(sp + "Color and texture");
			materialCS.color.setStyle(cs.colorCS);
			materialCS.emissive.setStyle(cs.emissiveCS);
			// materialCS.specular.setStyle(cs.specularCS); 
			materialCS.metalness = cs.metalness;
			materialCS.transparent = true;
			materialCS.opacity = cs.opaciteCS;
			materialCS.map = choixTextures[cs.nameTexture]
			folderColorsSundial.addColor(cs, 'colorCS').name('reflection').onChange(function (e) {
				materialCS.color = new THREE.Color(e);
				cs.colorCS = materialCS.color.getStyle();
			});
			folderColorsSundial.addColor(cs, 'emissiveCS').name('emition').onChange(function (e) {
				materialCS.emissive = new THREE.Color(e);
				cs.emissiveCS = materialCS.emissive.getStyle();
			});
			folderColorsSundial.add(materialCS, 'metalness', 0, 1, 0.01)
				.onChange(function (e) { cs.metalness = e; materialCS.needsUpdate = true })
			folderColorsSundial.add(materialCS, 'roughness', 0, 1, 0.01)
				.onChange(function (e) { cs.roughness = e; materialCS.needsUpdate = true })
			folderColorsSundial.add(cs, 'opaciteCS', 0, 1, 0.01)
				.name('opacity').onChange(function (e) {
					materialCS.transparent = true;
					cs.opaciteCS = e;
					materialCS.opacity = e
				})
				.listen()
			folderColorsSundial.add(materialCS, 'wireframe')
				.onChange(function (v) {
					cs.wireframe = v
					materialGnomon.wireframe = v;
					materialHeuresSolaires.wireframe = v;
					materialHeuresLegalesSA.wireframe = v;
					materialHeuresLegalesWS.wireframe = v;
					materialArcsDiurnes.wireframe = v
				});
			folderColorsSundial.add(cs, 'nameTexture', choixTextures)
				.name('Texture')
				.onFinishChange(function (t) {
					switch (t) {
						case 'JPG-PNG': lireFichierTexture(); break
						//case 'SVG':LireFichierSVG();break
						default: textureCS = t
						    cs.	dataURLtexture=""  
							materialCS.map = textureCS
							materialCS.emissiveMap = textureCS
							materialCS.needsUpdate = true
					}
				})
				.listen()


			const folderHours = gui.addFolder(sp + 'Hours');
			materialHeuresSolaires.color.setStyle(cs.colorHS);
			materialHeuresLegalesSA.color.setStyle(cs.colorHLSummerAutums);
			materialHeuresLegalesWS.color.setStyle(cs.colorHLWinterSpring);
			materialHeuresAntiques.color.setStyle(cs.colorHeuresAntiques);
			materialHeuresBabyloniques.color.setStyle(cs.colorHeuresBabyloniques);
			materialHeuresItaliques.color.setStyle(cs.colorHeuresItaliques);
			materialHeuresSDSA.color.setStyle(cs.colorHeuresSDSA);
			materialHeuresSDWS.color.setStyle(cs.colorHeuresSDWS);
			materialHeuresHPSA.color.setStyle(cs.colorHeuresHPSA);
			materialHeuresHPWS.color.setStyle(cs.colorHeuresHPWS);
			materialAnalem.color.setStyle(cs.colorAnalem);


			folderHours.add(cs, 'heuresSolaires')
				.name(HS)
				.onChange(function (e) {
					if (RTSpolyhedre()) { cs.polyheuresSolaires[nfaceActive] = e }
					if (e) { cs.textSizeHS = cs.hoursTextSize; TracerHeuresSolaires() } else { cadranSolaireGroup.remove(heuresSolairesGroup) }
				})
				.listen();
			folderHours.addColor(cs, 'colorHS')
				.name('      color-> ')
				.onChange(function (e) {
					materialHeuresSolaires.color = new THREE.Color(e);
					cs.colorHS = materialHeuresSolaires.color.getStyle()
				})

			folderHours.add(cs, 'heuresLegalesSummerAutums')
				.name(HLSA)
				.onChange(function (e) {
					if (RTSpolyhedre()) { cs.polyheuresLegalesSummerAutums[nfaceActive] = e }
					if (e) { cs.textSizeSA = cs.hoursTextSize; TracerHeuresLegalesSA() } else { cadranSolaireGroup.remove(heuresLegalesGroupSA) }
				})
				.listen();
			folderHours.addColor(cs, 'colorHLSummerAutums')
				.name('      color-> ')
				.onChange(function (e) {
					materialHeuresLegalesSA.color = new THREE.Color(e);
					cs.colorHLSummerAutums = materialHeuresLegalesSA.color.getStyle()
				})


			folderHours.add(cs, 'heuresLegalesWinterSpring')
				.name(HLWS)
				.onChange(function (e) {
					if (RTSpolyhedre()) { cs.polyheuresLegalesWinterSpring[nfaceActive] = e }
					if (e) { cs.textSizeWS = cs.hoursTextSize; TracerHeuresLegalesWS() } else { cadranSolaireGroup.remove(heuresLegalesGroupWS) }
				})
				.listen();
			folderHours.addColor(cs, 'colorHLWinterSpring')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresLegalesWS.color = new THREE.Color(e);
					cs.colorHLWinterSpring = materialHeuresLegalesWS.color.getStyle()
				})

			folderHours.add(cs, 'heuresAntiques')
				.name(HA)
				.onChange(function (e) {
					if (RTSpolyhedre()) { cs.polyheuresAntiques[nfaceActive] = e }
					if (e) { cs.textSizeHA = cs.hoursTextSize; TracerHeuresAntiques() } else { cadranSolaireGroup.remove(heuresAntiquesGroup) }
				})
				.listen();
			folderHours.addColor(cs, 'colorHeuresAntiques')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresAntiques.color = new THREE.Color(e);
					cs.colorHeuresAntiques = materialHeuresAntiques.color.getStyle()
				});

			folderHours.add(cs, 'heuresBabyloniques')
				.name(HB)
				.onChange(function (e) {
					if (RTSpolyhedre()) { cs.polyheuresBabyloniques[nfaceActive] = e }
					if (e) { cs.textSizeHB = cs.hoursTextSize; TracerHeuresBabyloniques() } else { cadranSolaireGroup.remove(heuresBabyloniquesGroup) }
				})
				.listen();
			folderHours.addColor(cs, 'colorHeuresBabyloniques')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresBabyloniques.color = new THREE.Color(e);
					cs.colorHeuresBayloniques = materialHeuresBabyloniques.color.getStyle()
				});

			folderHours.add(cs, 'heuresItaliques')
				.name(HI)
				.onChange(function (e) {
					if (RTSpolyhedre()) { cs.polyheuresItaliques[nfaceActive] = e }
					if (e) { cs.textSizeHI = cs.hoursTextSize; TracerHeuresItaliques() } else { cadranSolaireGroup.remove(heuresItaliquesGroup) }
				})
				.listen();
			folderHours.addColor(cs, 'colorHeuresItaliques')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresItaliques.color = new THREE.Color(e);
					cs.colorHeuresItaliques = materialHeuresItaliques.color.getStyle()
				});

			folderHours.add(cs, 'heuresSideralesSA')
				.name(HSDSA)
				.onChange(function (e) {
					if (RTSpolyhedre()) { cs.polyheuresSideralesSA[nfaceActive] = e }
					if (e) { cs.textSizeSDSA = cs.hoursTextSize; TracerHeuresSDSA() } else { cadranSolaireGroup.remove(heuresSDSAgroup) }
				})
				.listen();
			folderHours.addColor(cs, 'colorHeuresSDSA')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresSDSA.color = new THREE.Color(e);
					cs.colorHeuresSDSA = materialHeuresSDSA.color.getStyle()
				});

			folderHours.add(cs, 'heuresSideralesWS')
				.name(HSDWS)
				.onChange(function (e) {
					if (RTSpolyhedre()) { cs.polyheuresSideralesWS[nfaceActive] = e }
					if (e) { cs.textSizeSDWS = cs.hoursTextSize; TracerHeuresSDWS() } else { cadranSolaireGroup.remove(heuresSDWSgroup) }
				})
				.listen();
			folderHours.addColor(cs, 'colorHeuresSDWS')
				.name("      color->  ")
				.onFinishChange(function (e) {
					materialHeuresSDWS.color = new THREE.Color(e);
					cs.colorHeuresSDWS = materialHeuresSDWS.color.getStyle()
				});

			folderHours.add(cs, 'heuresPlanetairesSA')
				.name(HPSA)
				.onChange(function (e) {
					if (RTSpolyhedre()) { cs.polyheuresPlanetairesSA[nfaceActive] = e }
					if (e) { cs.textSizeHPSA = cs.hoursTextSize; TracerHeuresHPSA() } else { cadranSolaireGroup.remove(heuresHPSAgroup) }
				})
				.listen();
			folderHours.addColor(cs, 'colorHeuresHPSA')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresHPSA.color = new THREE.Color(e);
					cs.colorHeuresHPSA = materialHeuresHPSA.color.getStyle()
				});

			folderHours.add(cs, 'heuresPlanetairesWS')
				.name(HPWS)
				.onChange(function (e) {
					if (RTSpolyhedre()) { cs.polyheuresPlanetairesWS[nfaceActive] = e }
					if (e) { cs.textSizeHPWS = cs.hoursTextSize; TracerHeuresHPWS() } else { cadranSolaireGroup.remove(heuresHPWSgroup) }
				})
				.listen();
			folderHours.addColor(cs, 'colorHeuresHPWS')
				.name("      color->  ")
				.onChange(function (e) {
					materialHeuresHPWS.color = new THREE.Color(e);
					cs.colorHeuresHPWS = materialHeuresHPWS.color.getStyle()
				});

			const folderHoursOptions = folderHours.addFolder("Options (choose before tracing)")
			folderHoursOptions.add(cs, 'hoursTextSize', 0, 5, 0.1).name('Font size')

			const subDiv = {
				"meridienne": 12,
				"1 heure": 1,
				"30 min": 0.5,
				"15 min": 0.25,
				"10 min": 1 / 6,
				" 5 min": 1 / 12
			}
			folderHoursOptions.add(cs, "subDivisions", subDiv)
				.name('Subdivisions')
				.onChange(function (e) {
					if (RTSpolyhedre()) { cs.polysubDivisions[nfaceActive] = e }
					//TracerHeuresEtArcs()
				})

			const precisionH = {
				"one day": 1,
				"2 days": 2,
				"5 days": 5,
				"10 days": 10
			}
			folderHoursOptions.add(cs, "precisionHours", precisionH)
				.name('precision (days)')
				.onChange(TracerHeuresEtArcs())


			///// ARCS



			let dateArc = { day: 1, month: 1, function1() { tracerArc() }, function2() { effaceArcs() } };
			const folderArcs = gui.addFolder(sp + 'Diurnials arcs...');
			//  const folderDate= folderArcs.addFolder('Date')
			folderArcs.add(dateArc, "day", 1, 31, 1)
				.name("Day of the month")
			//  .onChange(function(v){dateArc.trace=false});
			folderArcs.add(dateArc, "month", 1, 12, 1)
				.name("Month of the year")
			//  .onChange(function(v){dateArc.trace=false});						  
			folderArcs.add(dateArc, 'function1')
				.name("trace one arc");


			function tracerArc() {
				let j = 0, s = "";
				j = JULIAN.DayOfYearGregorian(cs.year, dateArc.month, dateArc.day)
				s = dateArc.day + '/' + dateArc.month + '/' + cs.year
				cs.datesArcsDiurnes.push([s, TS.decSuns[j]])
				TracerArcsDiurnes()
			}
			function effaceArcs() {
				cs.datesArcsDiurnes = [[]]
				cs.equinoxeAndSolstices = false
				cs.arcZodiaque = false
				TracerArcsDiurnes()
			}

			gequinoxeAndSolstices = folderArcs.add(cs, 'equinoxeAndSolstices')
				.name('Equinoxe and solstices')
				.onChange(function (v) {
					cs.equinoxeAndSolstices = v;
					if (v) {
						cs.datesArcsDiurnes.unshift(['solstice', base.toRad(-oe)])
						cs.datesArcsDiurnes.unshift(['solstice', base.toRad(oe)])
						cs.datesArcsDiurnes.unshift(['equinoxe', 0])
					}
					else {
						cs.datesArcsDiurnes = cs.datesArcsDiurnes.filter(function (d) {
							return ((d[0] !== 'solstice') && (d[0] !== 'equinoxe'))
						})
					}
					if (RTSpolyhedre()) { cs.polyequinoxeAndSolstices[nfaceActive] = v
										  cs.polydatesArcsDiurnes[nfaceActive] = cs.datesArcsDiurnes
					 					}
					TracerArcsDiurnes()
				})
				.listen();

			const zodiac1 = 20.1, zodiac2 = 11.5   // données astrologiques, précision illusoire
			garcsZodiaque = folderArcs.add(cs, 'arcsZodiaque')
				.name('zodiacal arcs')
				.onChange(function (v) {
					cs.arcZodiaque = v
					if (v) {
						cs.datesArcsDiurnes.unshift(['Z', base.toRad(-zodiac1)])
						cs.datesArcsDiurnes.unshift(['Z', base.toRad(zodiac1)])
						cs.datesArcsDiurnes.unshift(['Z', base.toRad(-zodiac2)])
						cs.datesArcsDiurnes.unshift(['Z', base.toRad(zodiac2)])
					}
					else {
						cs.datesArcsDiurnes = cs.datesArcsDiurnes.filter(function (d) {
							return (d[0] !== 'Z')
						})
					}
					if (RTSpolyhedre()) { cs.polyarcsZodiaque[nfaceActive] = v 
										  cs.polydatesArcsDiurnes[nfaceActive] = cs.datesArcsDiurnes
					}
					TracerArcsDiurnes()
				})
				.listen();

			folderArcs.add(dateArc, 'function2')
				.name("delete all arcs");

			materialArcsDiurnes.color.setStyle(cs.colorequinoxeAndSolstice);
			folderArcs.addColor(cs, 'colorequinoxeAndSolstice')
				.name("color ")
				.onChange(function (e) {
					materialArcsDiurnes.color = new THREE.Color(e);
					cs.colorequinoxeAndSolstice = materialArcsDiurnes.color.getStyle()
				});

			const precisionA = {
				"one minute": 1,
				" 5 min": 5,
				"10 min": 15,
				"30 min": 30,
				"60 min": 60
			}
			folderArcs.add(cs, "precisionArcs", precisionA)
				.name('precision (min)')
				.onChange(TracerHeuresEtArcs());

			///// DEVISE
			const folderDevise = gui.addFolder('Motto ...');
			folderDevise.add(cs, 'devise').name('text')
				.onChange(function (v) {
					cs.devise = v;
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				});
			folderDevise.add(cs, 'deviseSize', 0, 5, 0.1).name('font size')
				.onChange(function (v) {
					cs.deviseSize = v;
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				});
			folderDevise.add(cs, "positionDevisex", -500, 500, 0.1)
				.name("← →")
				.onChange(function () {
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				})
				.onFinishChange(function () {
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				})
				.listen()
			folderDevise.add(cs, "positionDevisey", -500, 500, 0.1)
				.name("↑ ↓")
				.onChange(function () {
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				})
				.onFinishChange(function () {
					EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)
				})



			///// Displays and animations


			const folderView = gui.addFolder(sp + 'Displays and animations');



			folderView.add(cs, "axesESZ").name("East,South,Zenith")
				.onChange(function (e) { axesESZHelper.visible = e })
				.listen()

			folderView.add(cs, "axesXYZ").name("axes X,Y,Z")
				.onChange(function (e) {
					axeX.visible = e; axeY.visible = e; axeZ.visible = e
					//if (RTSpolyhedre()){axeZ.setDirection(new THREE.Vector3(0, 0, -1))}else{axeZ.setDirection(new THREE.Vector3(0, 0, 1))}
					if (e == true) { EcrireXYZ() } else { effacelisteMesh(labelAxesListeMesh, groupAxes) }
				})
				.listen()

			folderView.add(cs, "voirTerre").name("Earth")
				.onChange(function (e) {
					cs.voirTerre = e; PlacerLaTerre()
				})
				.listen()


			const gCircles = folderView.add(cs, "ecliptique").name("circles & vernal point")
				.onChange(function () { PlacerLeSoleil() })
				.listen()
			helpGui(gCircles, "ecliptic circle (yellow), equatorial circle (white)<br>vernal point (gray sphere), sun(yellow sphere)")

			const gSphereArmilaire = folderView.add(cs, "sphereArmilaire").name("sphere armilaire")
				.onChange(function (v) {
					v ? tracerSphereArmilaire() : effacerSphereArmilaire()
				})
			helpGui(gSphereArmilaire, "ecliptic circle (yellow), equatorial circle (white)<br>vernal point (gray sphere), sun(yellow sphere)<br>horizon (blue), local meridien (green)<br>tropic and polar circles (gray)")


			folderView.add(cs, "vrotscene", 0, 10, 1)
				.name('Rotation of the scene')
				.listen;

			folderView.add(cs, "dampingFactor", 1, 20, 1).name("Damping");

			folderView.add(cs, "vrotClouds", 1, 10, 1).name("Rotation of clouds");

			//// backGround
			//console.log(cs.background)
			folderView.addColor(cs, 'background')
				.name('wallpaper')
				.onChange(function () {
					cs.milkyWay = false
					scene.background = new THREE.Color(cs.background)
				})
			//.onFinishChange(function () {localStorage.setItem("BackGround",cs.background)})
			/// link

			folderView.add(cs, 'milkyWay')
				.name('milky Way')
				.onChange(function (e) {
					if (e) {
						scene.background = milkyWaybackGround
						//scene.environment = milkyWaybackGround 
						//   scene.backgroundRotation = new THREE.Euler(1,0.5,0.2,"XYZ")
						//   console.log(scene)
					} else { scene.background = new THREE.Color(cs.background) }
				})
				.listen()

			folderView.add(cs, "linkMedia").name("link web")
			const btnMedia = { lireMedia() { if (cs.linkMedia.length > 0) { window.open(cs.linkMedia) } } }
			folderView.add(btnMedia, "lireMedia").name("open link")


			///// EXPORT
			const gfolderDownLoad = gui.addFolder(sp + 'Download sundial, ephemeris, 3D file...');
			helpGui(gfolderDownLoad, "Export the sundial (json format), or: \n the SVG file, the csv file, the 3D model, the ephemeris, the HTML file...")
			const ButtonDownload = {
				functionDownload() {
					effacelisteMesh(labelAxesListeMesh, groupAxes)
					let e = cs.export
					if (e == "Sundial(.JSON)") {
						cs.posCamera = camera.position.toArray()
						if (RTSpolyhedre()) { rapellerFace(0) };   ////  !!!!!! important
						saveString(JSON.stringify(cs, null, 2), cs.nameFile + '.json')
					}
					if (e == "Spreadsheet(.CSV)") {
						//initCSVtext(); TracerHeuresEtArcs();
						saveString(CSVtext, cs.nameFile + '.csv')
					}
					if (e == "Ephemeris(.CSV)") { saveString(Ephemerid(cs.year), 'Ephemeris' + cs.year + '.csv') };
					if (e == "3D(.PLY)") { saveString(GenererPLY(), cs.nameFile + numFace + ".PLY") }//; heuresGroupsRemove();initPol(polyhedre) ;
					if (e == "3D(.OBJ)") { saveString(GenererOBJ(), cs.nameFile + numFace + ".OBJ") };
					if (e == "3D(.STL)") { saveString(GenererSTL(), cs.nameFile + numFace + ".STL") };
					if (e == "3D(.GLTF)") { GenererGLTF(numFace) };
					if (e == "Vector graphic(.SVG)") {
						construireFichierSVG()
						saveString(SVGtext, cs.nameFile + '.svg')
					};
					if (e == "Params (.HTML)") { saveString(HTLM(cs), cs.nameFile + '.html') }
					if (RTSpolyhedre()) {
						VoirPoly2D = false; TracerHeuresEtArcs()
						EcrireXYZ()
						if (e.indexOf("3D") != -1) { TracerCadranRTS("polyedric") }
					}
				}
			}


			//			

			const gButtonDownload = gfolderDownLoad.add(ButtonDownload, 'functionDownload').name('Download');
			helpGui(gButtonDownload, "Save the sundial in the chosen format <br>(JSON, SVG, CSV, PLY, OBJ, STL, GLTF, HTML, Ephemeris)")
			const gnameFile = gfolderDownLoad.add(cs, "nameFile").name("File name")
			helpGui(gnameFile, "Name of the file to save")

			gfolderDownLoad.add(cs, "export",
				["Sundial(.JSON)", "Vector graphic(.SVG)", "Spreadsheet(.CSV)", "3D(.PLY)", "3D(.OBJ)", "3D(.STL)", "3D(.GLTF)",
					"Params (.HTML)", "Ephemeris(.CSV)"])
				.name('Type of file')
				.onChange(function (e) {
					if (e == "Ephemeris(.CSV)") { gButtonDownload.name('Save ephemeris' + cs.year) }
					else { gButtonDownload.name('Save ' + cs.nameFile + e.substring(e.indexOf("(") + 1, e.indexOf(")"))) }
					if (e == "Vector graphic(.SVG)") { gunitsSVG.show() } else { gunitsSVG.hide() };
					if ((e == "Spreadsheet(.CSV)") || (e == "Ephemeris(.CSV)")) { gsepCSV.show() } else { gsepCSV.hide() }
					if ((e.indexOf("3D") != -1) && (RTSpolyhedre())) { gchoixExportPoly.show() } else { gchoixExportPoly.hide() }
				});

			function tracerUneFace() {
				meshGnomons[nfaceActive].remove(styleToriquePoly)
				//let csGroup=cadranSolaireGroup.clone(true)
				cadranSolaireGroup.clear()
				rapellerFace(nfaceActive)
				TracerHeuresEtArcs()
				EcrireDevise(cs.polyDev[nfaceActive], cs.polyDevx[nfaceActive], cs.polyDevy[nfaceActive])
				cadranSolaireGroup.add(meshFaces[nfaceActive])
				cadranSolaireGroup.add(meshGnomons[nfaceActive])
				const vNorm = new THREE.Vector3()
				quaternion.setFromUnitVectors(vNorm.fromArray(normalsFaces[nfaceActive]), new THREE.Vector3(0, 1, 0))
				cadranSolaireGroup.setRotationFromQuaternion(quaternion)
				// console.log(cadranSolaireGroup)
				// heuresGroupsRemove()
				// initPol(polyhedre)
			}

			const objExportPoly = { "choix": "?" }

			const gchoixExportPoly = gfolderDownLoad.add(objExportPoly, "choix", ["?", "full polyhedra", "active face"])//,"all the faces","full polyhedra",])
				.name("face to export?")
				.onChange(function (e) {
					if (e == "full polyhedra") { TracerCadranRTS("polyedric") }
					if (e == "active face") { tracerUneFace(); numFace = "-f" + (nfaceActive + 1).toString() }
					objExportPoly.choix = "?"
				})
			helpGui(gchoixExportPoly, "Export the full polyhedra or the active face")


			const absoluteUnits = {
				"millimeters": "mm",
				"quarters-millimeters(0.25mm)": "Q",
				"centimeters": "cm",
				"inches (2.54cm)": "in",
				"pixels": "px",
				"auto": "auto"
			}
			const gunitsSVG = gfolderDownLoad.add(cs, "unitSVG", absoluteUnits)
				.name('SVG units')
			helpGui(gunitsSVG, "Choose the units for the SVG file")

			const separateurCSV = {
				"semicolon": ";",
				"comma ": ",",
				"espace": " "
			}
			const gsepCSV = gfolderDownLoad.add(cs, "separateurCSV", separateurCSV)
				.name('CSV separator')
			helpGui(gsepCSV, "Choose the separator for the CSV file")



			gunitsSVG.hide();
			gsepCSV.hide()
			gchoixExportPoly.hide()


			// // Exemples --------------------------------------------------------------------------------------

			const folderSamples = gui.addFolder(sp + "Exemples")
			let urlServeur = location.href
			function newSundial(nf) {
				if (urlServeur.indexOf("#") > 0) { urlServeur = urlServeur.substring(0, urlServeur.indexOf("#")) }
				window.open(urlServeur + "#" + nf)
			}
			let objEx = {
				myEx1: function () { newSundial('Bab&Ita-DSavoie-p278.json') },
				myEx2: function () { newSundial('Antiques-DSavoie-p301.json') },
				myEx3: function () { newSundial('Sideral-Savoie.json') },
				myEx4: function () { newSundial('CollinEx1.json') },
				myEx5: function () { newSundial('CollinEx4.json') },
				myEx6: function () { newSundial('LambertAustral.json') },
				myEx7: function () { newSundial('LambertBoreal.json') },
				myEx8: function () { newSundial('ParentOccidental.json') },
				myEx9: function () { newSundial('CadranHerstmonceux.json') },
				myEx10: function () { newSundial('BifilaireOslo.json') },
				myEx11: function () { newSundial('HorizontalCusco.json') },
				myEx12: function () { newSundial('SpheriqueOeilleton.json') },
				myEx13: function () { newSundial('PolaireCylindrique.json') },
				myEx14: function () { newSundial('ConeDeclinant.json') },
				myEx15: function () { newSundial('Liberty.json') },
				myEx16: function () { newSundial('ToleOndulee.json') },
				myEx17: function () { newSundial('Paraboloid.json') },
				myEx18: function () { newSundial('TruncCube.json') },
				myEx19: function () { newSundial('Jonhson48.json') },
				myEx20: function () { newSundial('CubeOctaedre.json') },
				myEx21: function () { newSundial('Rhombobicubioctaedre.json') },
				myEx22: function () { newSundial('TourDesVents.json') },
				myEx23: function () { newSundial('MaquetteYMcspt11.json') },
				myEx24: function () { newSundial('Mobius.json') },
				myEx25: function () { newSundial('AstroidalEllipsoid.json') },
				myEx26: function () { newSundial('ToreDeKlein.json') }
			}
			const CadPolairesEx = folderSamples.addFolder('Polar or straigth style');
			CadPolairesEx.add(objEx, 'myEx1').name("Bab&Ita-D.Savoie-p278");
			CadPolairesEx.add(objEx, 'myEx2').name("Hours antics-D.Savoie p301")
			CadPolairesEx.add(objEx, 'myEx3').name('Sideral-DSavoie-p291');
			CadPolairesEx.add(objEx, 'myEx11').name('Horizontal Cusco (Perou)');

			const BifilairesEx = folderSamples.addFolder('Bifilar');
			BifilairesEx.add(objEx, 'myEx4').name("D.Collin Ex1");
			BifilairesEx.add(objEx, 'myEx5').name("D.Collin Ex4");
			BifilairesEx.add(objEx, 'myEx10').name("Generalised Bifilar Oslo");

			const AnalemEx = folderSamples.addFolder('Analemmatic');
			AnalemEx.add(objEx, 'myEx6').name("Lambert austral");
			AnalemEx.add(objEx, 'myEx7').name("Lambert boreal");
			AnalemEx.add(objEx, 'myEx8').name("Parent Occidental");
			AnalemEx.add(objEx, 'myEx9').name("Herstmonceux");
			AnalemEx.add(objEx, 'myEx23').name("Retrogradation de l'ombre");

			const RayTracingEx = folderSamples.addFolder('Ray Tracing sundials');
			RayTracingEx.add(objEx, 'myEx12').name("Spheric with oeilleton");
			RayTracingEx.add(objEx, 'myEx13').name("Polar cylindric sundial");
			RayTracingEx.add(objEx, 'myEx14').name("Declining Cone");
			RayTracingEx.add(objEx, 'myEx15').name("Lyberty");

			const ParametricEx = folderSamples.addFolder('Parametric');
			ParametricEx.add(objEx, 'myEx16').name("Corrugated sheet");
			ParametricEx.add(objEx, 'myEx17').name("Paraboloid");
			ParametricEx.add(objEx, 'myEx24').name("Ruban of Mobius");
			ParametricEx.add(objEx, 'myEx25').name("Astroidal Ellipsoid");
			ParametricEx.add(objEx, 'myEx26').name("Tore de Klein");

			const PolyedreEx = folderSamples.addFolder('Polyedric');
			PolyedreEx.add(objEx, 'myEx18').name("Truncated Cube");
			PolyedreEx.add(objEx, 'myEx20').name("Truncated Cube Octaedre");
			PolyedreEx.add(objEx, 'myEx21').name("Rhombobicubioctaedre");
			PolyedreEx.add(objEx, 'myEx19').name("Jonhson 48");
			PolyedreEx.add(objEx, 'myEx22').name("Tour des vents (Athènes)");


			//generateGeometry;   

			scene.add(axeLocalisation);
			scene.add(cadranSolaireGroup);
			scene.add(axeMondeGroup);
			scene.add(earthGroup);

			//			MiseEnPlaceCadranEtGnomon()  // YM: les 5 lignes commentées sont déjà dans initMenu() appelé plus bas

			//			cadranSolaireGroup.add(cadran);

			orienterAxedumonde()
			//			PlacerLaTerre()
			//eulerCsGroup();
			//eulerEarthGroup() 

			//			PlacerLeSoleil();
			//			PlacerLaTerre();
			sphereEarth.rotation.y = -Math.PI * 0.5;

			cs.autoCloseMenu = true


			for (let g = 0; g < gui.folders.length; g++) {
				gui.folders[g].$title.style.color = couleurMenu
				gui.folders[g].close()
				if (cs.autoCloseMenu) {
					gui.folders[g].domElement.addEventListener("click", function () {
						for (let ag = 0; ag < gui.folders.length; ag++) {
							if (ag !== g) { gui.folders[ag].close() }
						}
					})
				}
			}


			const linkEditor = "https://svgedit.netlify.app/editor/index.html"
			//const linkEditor = "./editor/index.html"

			const btnEditSVG = { EditSVG() { window.open(linkEditor) } }
			gui.add(btnEditSVG, "EditSVG").name("Editor svg")

			CadPolairesEx.close()
			BifilairesEx.close()
			AnalemEx.close()
			RayTracingEx.close()
			ParametricEx.close()
			PolyedreEx.close()

			initMenu(cs.typeCadran)
			scene.background = new THREE.Color(cs.background);
			materialCS.opacity = cs.opaciteCS
			materialCS.metalness = cs.metalness
			materialCS.wireframe = cs.wireframe
			if (cs.dataURLtexture == "") { textureCS = choixTextures[cs.nameTexture] }
			else {
				textureLoader.load(cs.dataURLtexture,
					function (texture) {
						//textureFile = texture; textureFile.name = 'file'
						materialCS.map = texture
						materialCS.emissiveMap = texture
						materialCS.needsUpdate = true
					})
			}
			materialCS.map = textureCS
			materialCS.emissiveMap = textureCS
			materialCS.wrapT = THREE.RepeatWrapping;
			materialCS.wrapS = THREE.RepeatWrapping;
			materialCS.colorSpace = THREE.SRGBColorSpace;
			materialCS.needsUpdate = true

			EcrireDevise(cs.devise, cs.positionDevisex, cs.positionDevisey)

			if (cs.typedataURL == '.obj') {
				objloader.load(cs.dataURL, function (Lucymesh) {
					TracerMesh(Lucymesh)
					TracerHeuresEtArcs()
				})
			}

			if (cs.typedataURL == '.ply') {
				plyloader.load(cs.dataURL, function (LucyGeom) {
					const Lucymesh = new THREE.Mesh(LucyGeom, materialCS)
					Lucymesh.geometry.computeVertexNormals()
					TracerMesh(Lucymesh)
					TracerHeuresEtArcs()
				})
			}


			EcrireXYZ()

			if (NouveauCadran == false) {
				gTypeCadran.hide()
				gtypeForme.hide()
			}

			camera.position.set(cs.posCamera[0], cs.posCamera[1], cs.posCamera[2]);
			RotationSoleil(cs.vrotSun)
			if (cs.milkyWay) { scene.background = milkyWaybackGround } else { scene.background = new THREE.Color(cs.background) }


		}//end init



		//  EXPORT---------------------------------------------------------------------------------

		function preparerExport() {
			if (lineRay != undefined) { lineRay.visible = false }
			axeLocalisation.visible = false;
			if (styleTorique != undefined) { styleTorique.visible = false }
			if (styleToriquePoly != undefined) { styleToriquePoly.visible = false }
			// for (let index = 0; index < nbFaces;index++) {
			// 				if (index!=nfaceActive){meshFaces[index].visible=false}}
		}

		function GenererPLY() {
			const plyExporter = new PLYExporter();
			preparerExport()
			let s = "";
			if (cs.typeCadran == BF) { cadranSolaireGroup.remove(gnomon) }
			try { s = plyExporter.parse(cadranSolaireGroup, data => { }, { binary: false }) }
			catch (err) { alert("Parse error") }
			if (cs.typeCadran == BF) { cadranSolaireGroup.add(gnomon) }
			// if (RTSpolyhedre()){heuresGroupsRemove();initPol(polyhedre) } 
			return s
		}

		function GenererOBJ() {
			const objExporter = new OBJExporter();
			preparerExport()
			let s = "";
			if (cs.typeCadran == BF) { cadranSolaireGroup.remove(gnomon) }
			render()
			try { s = objExporter.parse(cadranSolaireGroup) }
			catch (err) { alert("Parse error") }
			if (cs.typeCadran == BF) { cadranSolaireGroup.add(gnomon) }
			return s
		}

		function GenererSTL() {
			const stlExporter = new STLExporter();
			preparerExport()
			let s = "";
			if (cs.typeCadran == BF) { cadranSolaireGroup.remove(gnomon) }
			render()
			try { s = stlExporter.parse(cadranSolaireGroup, { binary: false }) }
			catch (err) { alert("Parse error") }
			if (cs.typeCadran == BF) { cadranSolaireGroup.add(gnomon) }
			return s
		}

		function GenererGLTF(nf) {
			const gltfExporter = new GLTFExporter();
			preparerExport()
			render()
			gltfExporter.parse(cadranSolaireGroup,
				function (gltf) {
					const s = JSON.stringify(gltf, null, 2)
					saveString(s, cs.nameFile + nf + ".GLTF")
				},
				function (error) { console.log('gltf error happened') })
		}



		//-------------------------------------------------------------------------------------------------------------

		function orienterAxedumonde() {

			axeMonde.setDirection(new THREE.Vector3(0, Math.sin(cs.lati * Math.PI / 180),
				-Math.cos(cs.lati * Math.PI / 180)));
			//axeMonde.setLength(600, 30, 10);
			//   helperLight.update()
			//   axeMonde.visible=cs.voirTerre;
			//   axeMonde.visible=false;
			//tracerEquateurCeleste() 

		}


		let ellipseEq, spherePV, ellipseEclip, horizon, meridien, tropiqueNord, tropiqueSud, polaireNord, polaireSud, axeArmilaire

		// const curveEquateur = new THREE.EllipseCurve(
		// 	0,  0,            // ax, aY
		// 	Dst, Dst,           // xRadius, yRadius
		// 	0,  2 * Math.PI,  // aStartAngle, aEndAngle
		// 	false,            // aClockwise
		// 	0 );                // aRotation

		const RTropique = Dst * Math.cos(base.toRad(oe))
		const curveTropique = new THREE.EllipseCurve(
			0, 0,            // ax, aY
			RTropique, RTropique,           // xRadius, yRadius
			0, 2 * Math.PI,  // aStartAngle, aEndAngle
			false,            // aClockwise
			0);

		const RPolaire = Dst * Math.cos(base.toRad(90 - oe))
		const curvePolaire = new THREE.EllipseCurve(
			0, 0,            // ax, aY
			RPolaire, RPolaire,           // xRadius, yRadius
			0, 2 * Math.PI,  // aStartAngle, aEndAngle
			false,            // aClockwise
			0);

		//const pointsEq = curveEquateur.getPoints( 50 );
		const pointsTropiqueNord = curveTropique.getPoints(50);
		const pointsTropiqueSud = curveTropique.getPoints(50);
		const pointsPolairesNord = curvePolaire.getPoints(50);
		const pointsPolairesSud = curvePolaire.getPoints(50);
		const geometryHorizon = new THREE.RingGeometry(Dst * 1.02, Dst * 0.98, 64, 64)
		const geometryEq = new THREE.RingGeometry(Dst * 1.002, Dst * 0.998, 64, 64)
		const geometryTropiqueNord = new THREE.BufferGeometry().setFromPoints(pointsTropiqueNord);
		const geometryTropiqueSud = new THREE.BufferGeometry().setFromPoints(pointsTropiqueSud);
		const geometryPolaireNord = new THREE.BufferGeometry().setFromPoints(pointsPolairesNord);
		const geometryPolaireSud = new THREE.BufferGeometry().setFromPoints(pointsPolairesSud);
		const geometryAxeArmilairene = new THREE.CylinderGeometry(RPolaire / 200, RPolaire / 200, Dst * 2.25)
		const materialEq = new THREE.LineBasicMaterial({ color: 0xffffff });
		const materialEclip = new THREE.LineBasicMaterial({ color: 0xffff00 });
		const materialHorizon = new THREE.LineBasicMaterial({ color: 0x0a0aff });
		const materialMeridien = new THREE.LineBasicMaterial({ color: 0x00ff00 });


		function tracerEquateurCeleste() {
			if (ellipseEq != undefined) { scene.remove(ellipseEq) }
			ellipseEq = new THREE.Line(geometryEq, materialEq)
			scene.add(ellipseEq)
			ellipseEq.rotation.x = base.toRad(cs.lati);
			// const AxeArmilaire = axeMonde.clone()
			// AxeArmilaire.setLength(Dst*1.5)
			// scene.add(AxeArmilaire)
		}

		function tracerTropiques() {
			if (tropiqueNord != undefined) { scene.remove(tropiqueNord) }
			if (tropiqueSud != undefined) { scene.remove(tropiqueSud) }
			tropiqueNord = new THREE.Line(geometryTropiqueNord, materialEq);
			tropiqueSud = new THREE.Line(geometryTropiqueSud, materialEq);
			tropiqueNord.rotation.x = base.toRad(cs.lati);
			tropiqueSud.rotation.x = base.toRad(cs.lati);
			tropiqueNord.translateZ(-Dst * Math.sin(oe * Math.PI / 180))
			tropiqueSud.translateZ(Dst * Math.sin(oe * Math.PI / 180))
			scene.add(tropiqueNord)
			scene.add(tropiqueSud)
		}

		function tracerPolaires() {
			if (polaireNord != undefined) { scene.remove(polaireNord) }
			if (polaireSud != undefined) { scene.remove(polaireSud) }
			polaireNord = new THREE.Line(geometryPolaireNord, materialEq);
			polaireSud = new THREE.Line(geometryPolaireSud, materialEq);
			polaireNord.rotation.x = base.toRad(cs.lati);
			polaireSud.rotation.x = base.toRad(cs.lati);
			polaireNord.translateZ(-Dst * Math.sin((90 - oe) * Math.PI / 180))
			polaireSud.translateZ(Dst * Math.sin((90 - oe) * Math.PI / 180))
			scene.add(polaireNord)
			scene.add(polaireSud)
		}


		function tracerHorizonEtMeridien() {
			if (horizon != undefined) { scene.remove(horizon) }
			horizon = new THREE.Line(geometryHorizon, materialHorizon);
			horizon.rotation.x = Math.PI / 2;
			scene.add(horizon)
			if (meridien != undefined) { scene.remove(meridien) }
			meridien = new THREE.Line(geometryEq, materialMeridien);
			meridien.rotation.y = Math.PI / 2;
			scene.add(meridien)
		}

		function tracerAxeArmilaire() {
			if (axeArmilaire != undefined) { axeMondeGroup.remove(axeArmilaire) }
			axeArmilaire = new THREE.Mesh(geometryAxeArmilairene, materialEq)

			axeArmilaire.parent = axeMonde
			// axeArmilaire.rotation.z=Math.PI/2
			// axeArmilaire.rotation.x = base.toRad(cs.lati);
			axeMondeGroup.add(axeArmilaire)
			axeArmilaire.rotation.x = base.toRad(cs.lati + 90);
		}
		materialEclip
		function tracerEcliptique(h) {
			tracerEquateurCeleste()
			let k = Dst, alpha = 0, asd
			asd = TS.ascRights[cs.dayofYear - 1]
			h = base.toRad(-(h - 12) * 15) - asd
			if (spherePV != undefined) { axeMondeGroup.remove(spherePV) }
			spherePV = new THREE.Mesh(geometrySun, materialGnomon);
			axeMondeGroup.add(spherePV);
			spherePV.parent = axeMonde;
			spherePV.position.z = k * Math.cos(h);
			spherePV.position.x = k * Math.sin(h);
			spherePV.position.y = 0;

			const axis = new THREE.Vector3(spherePV.position.x, spherePV.position.z, 0)
			axis.normalize()
			if (ellipseEclip != undefined) { axeMondeGroup.remove(ellipseEclip) }
			ellipseEclip = ellipseEq.clone()
			ellipseEclip.material = materialEclip
			axeMondeGroup.add(ellipseEclip);
			ellipseEclip.rotateOnAxis(axis, base.toRad(oe))
		}

		function effacerEcliptique() {
			cs.ecliptique = false
			scene.remove(ellipseEq); axeMondeGroup.remove(ellipseEclip); axeMondeGroup.remove(spherePV)
		}

		function tracerSphereArmilaire() {
			cs.ecliptique = true
			PlacerLeSoleil()
			tracerHorizonEtMeridien()
			tracerEquateurCeleste()
			tracerTropiques()
			tracerPolaires()
			tracerAxeArmilaire()
			PlacerLaTerre(true)
		}

		function effacerSphereArmilaire() {
			effacerEcliptique()
			scene.remove(horizon)
			scene.remove(meridien)
			scene.remove(tropiqueNord)
			scene.remove(tropiqueSud)
			scene.remove(polaireNord)
			scene.remove(polaireSud)
			axeArmilaire.visible = false
			PlacerLaTerre(false)
		}





		//--------------------------------------------------------------------------------------
		function PlacerLeSoleil() {
			let k = Dst;
			const v3 = new THREE.Vector3();

			let h, he, min, sec, y, m, d, dec, asc, eqt, date, sdate, hsol;

			//if(RTSpolyhedre){k=k*cs.Rpol/1200}

			h = Math.floor(cs.hsol);
			min = Math.floor((cs.hsol - h) * 60);
			sec = Math.floor((cs.hsol - h - min / 60) * 3600);
			//console.log(cs.hsol,sec)
			h = (h < 10) ? "0" + h : h;
			min = (min < 10) ? "0" + min : min;
			sec = (sec < 10) ? "0" + sec : sec;

			date = JULIAN.JDToCalendarGregorian(TS.jdates[cs.dayofYear - 1]);
			asc = base.toDeg(TS.ascRights[cs.dayofYear - 1])
			dec = base.toDeg(TS.decSuns[cs.dayofYear - 1]);
			eqt = Math.round(SEXA.secFromHourAngle(TS.eqtimes[cs.dayofYear - 1]));
			//hsol=cs.hsol + eqt/3600 +(cs.longi/15 - cs.offset_sec/3600); //correction de l'heure

			hsol = cs.hsol + eqt / 3600   // correction eq. du temps
			//if (cs.typeCadran != ANL) { hsol += cs.longi / 15 - cs.offset_sec / 3600 }   // pas d'heure légale avec un analemmatique
			//console.log(cs.typeCadran,ANL,cs.typeCadran!=ANL)
			hsol += cs.longi / 15 - cs.offset_sec / 3600 // correction longitude et decalage horaire
			d = Math.floor(date.day); m = date.month; y = date.month;
			d = (d < 10) ? "0" + d : d;
			m = (m < 10) ? "0" + m : m;
			sdate = d + "/" + m + "/" + date.year;  //date JJ/MM/YYYY

			sphereSun.position.z = k * Math.cos(base.toRad(dec)) * Math.cos(base.toRad(-(hsol - 12) * 15));
			sphereSun.position.x = k * Math.cos(base.toRad(dec)) * Math.sin(base.toRad(-(hsol - 12) * 15));
			sphereSun.position.y = k * Math.sin(base.toRad(dec));

			sphereSun.getWorldPosition(v3);
			light.position.set(v3.x, v3.y, v3.z).normalize();
			light.castShadow = (v3.y > 0)  // le soleil doit être au dessus de l'horizon		
			if (v3.y > 0) { materialCS.color.setStyle(cs.colorCS) } else { materialCS.color.setStyle("rgb(0,0,0)") };// la nuit tous les chats sont gris!

			labeltime.innerHTML = h + ":" + min + ':' + sec + "  " + sdate + " dec:" + dec.toFixed(3) + "°  asc:" + asc.toFixed(3) + "°  eqt:" + eqt.toFixed(0) + 's'

			if (cs.ecliptique) { tracerEcliptique(hsol, eqt) }
			else { effacerEcliptique() }

			if (cs.typeCadran == RTS) {
				if (lineRay != undefined) {
					lineRay.geometry.dispose()
					cadranSolaireGroup.remove(lineRay)
				}
				if (v3.y > 0) { CoordRayTracing((hsol - 12) / 12 * Math.PI, TS.decSuns[cs.dayofYear - 1], true) }
			}
		}




		// -------------------------------------------------------------------------------------------------------
		function CoordRayTracing(hrad, dec, trace = false) {   // hrad: angle horaire en radians de -Pi a Pi   dec: declinaison du soleil en radians

			if (VoirPoly2D) {
				const coord2D = CoordRayTracingPoly2D(hrad, dec)
				//console.log(coord2D)
				return {
					x: coord2D.x,
					y: -coord2D.z,
					z: coord2D.y,
					ok: coord2D.ok
				}
			}

			const [sh, ch] = base.sincos(-hrad)
			const [sd, cd] = base.sincos(dec)

			let coordRayCaster = new THREE.Vector3();   // coord. de l'ombre tore sur le cadran en coord. locales (c'est le pont 3D à trouver)
			//let coordRayCaster2D = new THREE.Vector3();
			//let intersectPoint=new THREE.Vector3();
			let intersects

			let k = Dst;  //constante arbitraire

			if (cs.typeForme != "polyedric") {
				rayOrigin.set(cs.xgnomon / cadran.scale.x, cs.ygnomon / cadran.scale.y, cs.zgnomon / cadran.scale.z)  // ces facteur d'echelle sont liés au dimensions du cadran	
				cadran.localToWorld(rayOrigin)
			}

			sphereSun.position.z = k * cd * ch   // calcul des coord. du soleil virtuel
			sphereSun.position.x = k * cd * sh
			sphereSun.position.y = k * sd
			sphereSun.getWorldPosition(rayDirection)   //memorisation dans le vecteur 3D rayDirection
			rayDirection.normalize();  // normalisation
			rayCaster.set(rayOrigin, rayDirection)
			intersects = rayCaster.intersectObject(cadran)  //le tore est-il à l'ombre du cadran?
			if (intersects.length > 0) {
				return {              // tore à l'ombre, ok=false
					x: 0,
					y: 0,
					z: 0,
					ok: false
				}
			} else {
				rayDirection.negate();  // changement de sens, le vecteur pointe vers l'origine du repère global
				rayCaster.set(rayOrigin, rayDirection)  // l'objet rayCaster a été initialisé au début du code par : const rayCaster = new THREE.Raycaster()  (variable globale)
				// rayCaster virtualise le rayon lumineux ayant direction du soleil (rayDirection) et passant par de centre du tore (rayOrigin) 
				intersects = rayCaster.intersectObject(cadran, false); // c'esi la ligne la plus importante du code: recherche de l'intersection du rayon et du cadran
				// le cadran est modélisé par un maillage de trangles
				if (intersects.length > 0) {                          // s'il ya au moins une intersection, les coord. du point sont dans intersects[0].point
					coordRayCaster = cadran.worldToLocal(intersects[0].point)   // on revient aux coord.locales
					coordRayCaster.set(coordRayCaster.x * cadran.scale.x, coordRayCaster.y * cadran.scale.y, coordRayCaster.z * cadran.scale.z)// il reste à remettre à l'échelle
					if (trace == true) {
						cadran.worldToLocal(rayOrigin)
						rayOrigin.set(rayOrigin.x * cadran.scale.x, rayOrigin.y * cadran.scale.y, rayOrigin.z * cadran.scale.z)

						const geometryRay = new THREE.BufferGeometry().setFromPoints([rayOrigin, coordRayCaster]);
						const materialRay = new THREE.LineBasicMaterial({ color: 0xffff00 });//ligne jaune
						lineRay = new THREE.Line(geometryRay, materialRay);
						cadranSolaireGroup.add(lineRay)
					}

// const alpha=Math.atan2(coordRayCaster.x,coordRayCaster.z)
// const R=cs.largeur/2 
// coordRayCaster.x=R*alpha
// coordRayCaster.z=cs.epaisseur
					return {
						x: coordRayCaster.x,   //retour des coord de l'ombre, en coord locales, ok=true
						y: coordRayCaster.y,
						z: coordRayCaster.z,
						ok: true

					}
				}
				else return {              // si pas d'ombre, ok=false
					x: 0,
					y: 0,
					z: 0,
					ok: false
				}
			}
		}

		//
		function CoordRayTracingPoly2D(hrad, dec) {
			const [sh, ch] = base.sincos(-hrad)
			const [sd, cd] = base.sincos(dec)

			let coordRayCaster = new THREE.Vector3();   // coord. de l'ombre tore sur le cadran en coord. locales (c'est le pont 3D à trouver)
			let intersects

			let k = Dst;
			sphereSun.position.z = k * cd * ch   // calcul des coord. du soleil virtuel
			sphereSun.position.x = k * cd * sh
			sphereSun.position.y = k * sd
			sphereSun.getWorldPosition(rayDirection)   //memorisation dans le vecteur 3D rayDirection
			rayDirection.normalize();  // normalisation
			rayCaster.set(rayOrigin, rayDirection)
			intersects = rayCaster.intersectObject(cadran)  //le tore est-il à l'ombre du cadran?
			if (intersects.length > 0) {
				return {              // tore à l'ombre, ok=false
					x: 0,
					y: 0,
					z: 0,
					ok: false
				}
			} else {
				rayDirection.negate();  // changement de sens, le vecteur pointe vers l'origine du repère global
				rayCaster.set(rayOrigin, rayDirection)  // l'objet rayCaster a été initialisé au début du code par : const rayCaster = new THREE.Raycaster()  (variable globale)
				// rayCaster virtualise le rayon lumineux ayant direction du soleil (rayDirection) et passant par de centre du tore (rayOrigin) 
				intersects = rayCaster.intersectObject(cadran, false); // c'esi la ligne la plus importante du code: recherche de l'intersection du rayon et du cadran
				// le cadran est modélisé par un maillage de trangles
				if (intersects.length > 0) {                          // s'il ya au moins une intersection, les coord. du point sont dans intersects[0].point
					coordRayCaster = meshGnomons[nfaceActive].worldToLocal(intersects[0].point)
					//	coordRayCaster.set(coordRayCaster.x * cadran.scale.x, coordRayCaster.y * cadran.scale.y, coordRayCaster.z * cadran.scale.z)// il reste à remettre à l'échelle
					return {
						x: coordRayCaster.x,   //retour des coord de l'ombre, en coord locales, ok=true
						y: coordRayCaster.y,
						z: coordRayCaster.z,
						ok: true
					}
				}
				else return {              // si pas d'ombre, ok=false
					x: 0,
					y: 0,
					z: 0,
					ok: false
				}
			}
		}

		// Terre ---------------------------------------------------------------------------------------------------
		function PlacerLaTerre(centrer = false) {
			let r, l;
			if (centrer) {
				r = cs.hauteur / 6; materialCS.wireframe = true; cs.wireframe = true
				if (RTSpolyhedre()) { r = cs.rayonPolyedre / 2 }
			} else {
				r = cs.hauteur * 0.9;
				materialCS.wireframe = false; cs.wireframe = false
				if (RTSpolyhedre()) { r = 2 * cs.rayonPolyedre }
			}
			//if (r < 100) { r = 100 }
			sphereEarth.scale.x = r; sphereEarth.scale.y = r; sphereEarth.scale.z = r;
			meshClouds.scale.set(sphereEarth.scale.x * cloudsScale, sphereEarth.scale.y * cloudsScale, sphereEarth.scale.z * cloudsScale);
			earthGroup.position.x = 0;
			if (centrer) { earthGroup.position.y = 0 } else { earthGroup.position.y = -r * 2 };
			earthGroup.position.z = 0;
			earthGroup.rotation.x = -base.toRad(90 - cs.lati);
			earthGroup.rotation.y = -base.toRad(cs.longi);
			earthGroup.visible = cs.voirTerre;
			axeTerre.setLength(r * 1.5, r * 1.5 * 0.1, r * 1.5 * 0.02);
			l = -earthGroup.position.y - r;
			axeLocalisation.setLength(l, 0.1 * l, 0.02 * l)
			axeLocalisation.visible = cs.voirTerre;

			//console.log(renderer.info)

		}

		//---------------------------------------------------------------------------------------------------------

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);

		}


		function animate() {

			controls.dampingFactor = cs.dampingFactor / 100;
			controls.update()
			if (cs.vrotscene > 0) { scene.rotation.y += 0.001 * cs.vrotscene } else { scene.rotation.y = 0 }
			meshClouds.rotation.y += 0.00005 * cs.vrotClouds;
			//render();
			renderer.render(scene, camera);
			stats.update();
			requestAnimationFrame(animate);

		}

		function render() { renderer.render(scene, camera) }


		//----------------------------------------------------------------------------------------------------------------------------------------------------
		///////////////////////////////////////////////////////////////////POLYEDRES/////////////////////////////////////////////////////////////////////////
		//----------------------------------------------------------------------------------------------------------------------------------------------------

		let categoryFolders, meshFace, gnomonGeometry, Rpol, copieGnomon,
			nbFaces = 0, guiSectionPoly, guichoixPoly, guichoixFace,
			quaternion = new THREE.Quaternion(),
			polyhedre, styleToriquePoly, geoTorePoly, gnomonPoly, VoirPoly2D = false
		let meshFacesGroup = new THREE.Group()
		let meshFaces = [], meshGnomons = [], normalsFaces = [], hauteursGnomons = [], centersFaces = [], rayonFace = []
		let nfaceActive = 0, aFace = 0, nFaceMax = -1, nFaceBase = -1
		let numFace = "", Lmax
		let lineSommetsFace
		let garcsZodiaque, gequinoxeAndSolstices;

		let
			polyheuresSolairesListeMesh = [],
			polyheuresLegalesListeMeshSA = [],
			polyheuresLegalesListeMeshWS = [],
			polyheuresAntiquesListeMesh = [],
			polyheuresBabyloniquesListeMesh = [],
			polyheuresItaliquesListeMesh = [],
			polyheuresSDSAListeMesh = [],
			polyheuresSDWSListeMesh = [],
			polyheuresHPSAListeMesh = [],
			polyheuresHPWSListeMesh = [],
			polyarcsDiurnesListeMesh = []


		let
			polyheuresSolairesGroup = [],
			polyheuresLegalesGroupSA = [],
			polyheuresLegalesGroupWS = [],
			polyheuresAntiquesGroup = [],
			polyheuresBabyloniquesGroup = [],
			polyheuresItaliquesGroup = [],
			polyheuresSDSAgroup = [],
			polyheuresSDWSgroup = [],
			polyheuresHPSAgroup = [],
			polyheuresHPWSgroup = [],
			polyarcsDiurnesGroup = []


		function PlacerGnomonPoly(x, y, f) {
			gnomonPoly.position.set(centersFaces[f].x, centersFaces[f].y, centersFaces[f].z)
			gnomonPoly.translateX(x)
			gnomonPoly.translateZ(-y)
		}


		function TracerGnomonPoly(h) {
			let geometryGnomonPoly

			if (gnomonPoly != undefined) { gnomonPoly.geometry.dispose() }

			if (h > 0) {
				geometryGnomonPoly = new THREE.CylinderGeometry(cs.egnomon / cs.conicity, cs.egnomon * cs.conicity, h, 16, 16)
				gnomonPoly = new THREE.Mesh(geometryGnomonPoly, materialGnomon)
			}
			else { gnomonPoly = new THREE.Mesh() }



			if (styleToriquePoly != undefined) { styleToriquePoly.geometry.dispose() }
			const k = Math.max(cs.egnomon, 0.2)
			geoTorePoly = new THREE.TorusGeometry(5 * k, k)
			styleToriquePoly = new THREE.Mesh(geoTorePoly, materialSun);

			styleToriquePoly.receiveShadow = false
			styleToriquePoly.castShadow = true;

		}

		function SommetsFace(N, Pol, local = true) {   // recherce des coords locales des sommets de la face N du polyhedre Pol
			const lf = Pol.face[N]
			const verticesFaceN = []
			for (let i = 0; i < lf.length; i++) {
				const j = Pol.face[N][i]
				const v = Pol.vertex[j]
				let verticeFace = new THREE.Vector3(v[0], v[1], v[2])
				verticeFace.applyEuler(new THREE.Euler((cs.incli - 90) / 180 * Math.PI, cs.decli / 180 * Math.PI, cs.rot / 180 * Math.PI, 'YXZ'))
				verticeFace.x *= cs.largeur
				verticeFace.y *= cs.hauteur
				verticeFace.z *= cs.epaisseur
				//verticeFace.multiplyScalar(Rpol)
				if (local) { meshGnomons[N].worldToLocal(verticeFace) } else[verticeFace.multiplyScalar(1.1)]
				//local= false -> mise en evidence de la face active par trace d'un polygone
				verticesFaceN.push(verticeFace);
			}
			const v0 = verticesFaceN[0]
			verticesFaceN.push(v0)
			return verticesFaceN
		}


		/////////////////////////////////////////////////////////////////////////////////////////////////////////
		function displayFaces(Pol) {
			Info(""); Info("Busy...")
			if (polyhedre == undefined) { return }
			let nSommetsParFace = 0, v, h, hmaxPoly
			let a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3()
			let normalFace = new THREE.Vector3()


			nbFaces = Pol.face.length
			hmaxPoly = 0
			Rpol = cs.rayonPolyedre
			//Rpol = 1

			// for (let i=0;i<meshGeometry.length;i++){
			// 	meshGeometry[i].dispose()
			// }
			// meshGeometry=[]
			//console.log(meshGeometry[0])

			effacelisteMesh(meshFaces, meshFacesGroup)
			effacelisteMesh(meshGnomons, meshFacesGroup)

			meshFaces = [], meshGnomons = [], normalsFaces = []
			normalsFaces = [], hauteursGnomons = [], centersFaces = []

			for (let f = 0; f < nbFaces; f++) {
				let sx = 0, sy = 0, sz = 0
				const lf = Pol.face[f]
				const verticesFaces = []
				nSommetsParFace = lf.length
				for (let i = 0; i < lf.length; i++) {
					const j = Pol.face[f][i]

					v = Pol.vertex[j]
					let verticeFace = new THREE.Vector3(v[0], v[1], v[2])
					verticeFace.applyEuler(new THREE.Euler((cs.incli - 90) / 180 * Math.PI, cs.decli / 180 * Math.PI, cs.rot / 180 * Math.PI, 'YXZ'))
					//Pol.vertex[j]=[verticeFace.x,verticeFace.y,verticeFace.z]
					//cs.incli=90; cs.decli=0; cs.rot=0
					verticeFace.x *= cs.largeur
					verticeFace.y *= cs.hauteur
					verticeFace.z *= cs.epaisseur
					//verticeFace.multiplyScalar(Rpol)
					sx += verticeFace.x; sy += verticeFace.y; sz += verticeFace.z

					if (i == 0) { a = verticeFace.clone() }
					if (i == 1) { b = verticeFace.clone() }
					if (i == 2) { c = verticeFace.clone() }

					verticesFaces.push(verticeFace);
					let verticeFaceInt = new THREE.Vector3()
					verticeFaceInt = verticeFace.clone()

					verticeFaceInt.multiplyScalar(0.8)
					verticesFaces.push(verticeFaceInt);
				}
				b.sub(a); c.sub(a)
				normalFace.crossVectors(b, c).normalize()

				normalsFaces.push(normalFace.toArray())

				const centerFace = new THREE.Vector3(sx / nSommetsParFace, sy / nSommetsParFace, sz / nSommetsParFace)
				centersFaces.push(centerFace)

				meshFace = new THREE.Mesh(new ConvexGeometry(verticesFaces), materialCS);

				meshFace.lookAt(new THREE.Vector3(0, 0, 0))

				meshFace.receiveShadow = true
				meshFaces.push(meshFace)

				h = centerFace.distanceTo(a)
				rayonFace.push(h)
				h = h / 3
				//h=Math.round(h*100)/100
				if (h > hmaxPoly) { hmaxPoly = h; nFaceMax = f }  //recherche d'une "grande" face;  rayonFace[nfaceMax] : rayon de la plus grande face
				if (cs.polyGz[f] == -1) { cs.polyGz[f] = h } else { h = cs.polyGz[f] }
				if (f == nFaceBase) { h = 0; cs.polyGz[f] = 0 }

				TracerGnomonPoly(h)
				meshFace.add(gnomonPoly)

				gnomonPoly.position.x = centerFace.x
				gnomonPoly.position.y = centerFace.y
				gnomonPoly.position.z = centerFace.z
				normalFace.add(centerFace)
				gnomonPoly.lookAt(normalFace)
				gnomonPoly.rotateX(Math.PI / 2)
				PlacerGnomonPoly(cs.polyGx[f], cs.polyGy[f], f)
				gnomonPoly.translateY(h / 2)

				meshGnomons.push(gnomonPoly)
				hauteursGnomons.push(h)
				gnomonPoly.castShadow = true
				gnomonPoly.receiveShadow = false
				//if (f==nfaceActive){meshFacesGroup.add(meshFace)}
				meshFacesGroup.add(meshFace)

			} //f

			cadranSolaireGroup.add(meshFacesGroup)


			tracerTouteslesDevises()

			if (nfaceActive > nbFaces) { nfaceActive = 0 }
			cadran = meshFaces[nfaceActive].clone()
			PlacerStyleToriquePoly(nfaceActive, hauteursGnomons[nfaceActive])

			if (typeof (BoutStyle) !== "undefined") { BoutStyle.geometry.dispose() };
			// let GeometryBout = new THREE.SphereGeometry(2*cs.egnomon*cs.conicity, 32, 16);
			// BoutStyle = new THREE.Mesh(GeometryBout, materialGnomon)
			BoutStyle = styleToriquePoly.clone()

			guichoixPoly.close()
			Info("")
		}

		function tracerTouteslesDevises() {
			for (let n = 0; n < nbFaces; n++) {
				cadran = meshFaces[n].clone()
				EcrireDevise(cs.polyDev[n], cs.polyDevx[n], cs.polyDevy[n], n)
			}
		}

		function tracerLaDevise(n) {
			cadran = meshFaces[n].clone()
			EcrireDevise(cs.polyDev[n], cs.polyDevx[n], cs.polyDevy[n], n)
		}





		function PlacerStyleToriquePoly(n, h) {
			meshGnomons[n].receiveShadow = false
			styleToriquePoly.receiveShadow = false

			meshGnomons[n].add(styleToriquePoly)
			styleToriquePoly.position.set(0, h / 2, 0)
			rayOrigin = styleToriquePoly.position.clone()
			meshGnomons[n].localToWorld(rayOrigin)
			PlacerLeSoleil()
			styleToriquePoly.castShadow = true
			// meshGnomons[n].add(axeX)
			// axeX.position.set(0, -h / 2, 0)
			// meshGnomons[n].add(axeZ)	
			// axeZ.position.set(0, -h / 2, 0)
			// axeZ.setDirection(new THREE.Vector3(0, 0, -1))

		}

		function memoriserFace(f) {
			cs.polyheuresSolaires[f] = cs.heuresSolaires
			polyheuresSolairesListeMesh[f] = heuresSolairesListeMesh
			polyheuresSolairesGroup[f] = heuresSolairesGroup

			cs.polyheuresLegalesSummerAutums[f] = cs.heuresLegalesSummerAutums
			polyheuresLegalesListeMeshSA[f] = heuresLegalesListeMeshSA
			polyheuresLegalesGroupSA[f] = heuresLegalesGroupSA

			cs.polyheuresLegalesWinterSpring[f] = cs.heuresLegalesWinterSpring
			polyheuresLegalesListeMeshWS[f] = heuresLegalesListeMeshWS
			polyheuresLegalesGroupWS[f] = heuresLegalesGroupWS

			cs.polyheuresAntiques[f] = cs.heuresAntiques
			polyheuresAntiquesListeMesh[f] = heuresAntiquesListeMesh
			polyheuresAntiquesGroup[f] = heuresAntiquesGroup

			cs.polyheuresBabyloniques[f] = cs.heuresBabyloniques
			polyheuresBabyloniquesListeMesh[f] = heuresBabyloniquesListeMesh
			polyheuresBabyloniquesGroup[f] = heuresBabyloniquesGroup

			cs.polyheuresItaliques[f] = cs.heuresItaliques
			polyheuresItaliquesListeMesh[f] = heuresItaliquesListeMesh
			polyheuresItaliquesGroup[f] = heuresItaliquesGroup

			cs.polyheuresSideralesWS[f] = cs.heuresSideralesWS
			polyheuresSDWSListeMesh[f] = heuresSDWSListeMesh
			polyheuresSDWSgroup[f] = heuresSDWSgroup

			cs.polyheuresSideralesSA[f] = cs.heuresSideralesSA
			polyheuresSDSAListeMesh[f] = heuresSDSAListeMesh
			polyheuresSDSAgroup[f] = heuresSDSAgroup

			cs.polyheuresPlanetairesWS[f] = cs.heuresPlanetairesWS
			polyheuresHPWSListeMesh[f] = heuresHPWSListeMesh
			polyheuresHPWSgroup[f] = heuresHPWSgroup

			cs.polyheuresPlanetairesSA[f] = cs.heuresPlanetairesSA
			polyheuresHPSAListeMesh[f] = heuresHPSAListeMesh
			polyheuresHPSAgroup[f] = heuresHPSAgroup

			cs.polyarcsZodiaque[f] = cs.arcsZodiaque
			cs.polyequinoxeAndSolstices[f] = cs.equinoxeAndSolstices
			cs.polydatesArcsDiurnes[f] = cs.datesArcsDiurnes

			cs.polysubDivisions[f] = cs.subDivisions

			polyarcsDiurnesListeMesh[f] = arcsDiurnesListeMesh
			polyarcsDiurnesGroup[f] = arcsDiurnesGroup

		}

		function memoriserTouteslesfaces() {
			for (let f = 0; f < nbFaces; f++) {
				memoriserFace(f)
			}
		}

		function effacerPolyListes(f) {
			effacelisteMesh(polyheuresSolairesListeMesh[f], polyheuresSolairesGroup[f])
			effacelisteMesh(polyheuresLegalesListeMeshSA[f], polyheuresLegalesGroupSA[f])
			effacelisteMesh(polyheuresLegalesListeMeshWS[f], polyheuresLegalesGroupWS[f])
			effacelisteMesh(polyheuresAntiquesListeMesh[f], polyheuresAntiquesGroup[f])
			effacelisteMesh(polyheuresBabyloniquesListeMesh[f], polyheuresBabyloniquesGroup[f])
			effacelisteMesh(polyheuresItaliquesListeMesh[f], polyheuresItaliquesGroup[f])
			effacelisteMesh(polyheuresSDSAListeMesh[f], polyheuresSDSAgroup[f])
			effacelisteMesh(polyheuresSDWSListeMesh[f], polyheuresSDWSgroup[f])
			effacelisteMesh(polyheuresHPWSListeMesh[f], polyheuresHPWSgroup[f])
			effacelisteMesh(polyheuresHPSAListeMesh[f], polyheuresHPSAgroup[f])
			cs.polyequinoxeAndSolstices[f] = false
			cs.polyarcsZodiaque[f] = false
			effacelisteMesh(polyarcsDiurnesListeMesh[f], polyarcsDiurnesGroup[f])
		}

		function effacerListesMesh() {

			effacelisteMesh(heuresSolairesListeMesh, heuresSolairesGroup);
			effacelisteMesh(heuresLegalesListeMeshSA, heuresLegalesGroupSA)
			effacelisteMesh(heuresLegalesListeMeshWS, heuresLegalesGroupWS)
			effacelisteMesh(heuresAntiquesListeMesh, heuresAntiquesGroup)
			effacelisteMesh(heuresBabyloniquesListeMesh, heuresBabyloniquesGroup)
			effacelisteMesh(heuresItaliquesListeMesh, heuresItaliquesGroup)
			effacelisteMesh(heuresSDSAListeMesh, heuresSDSAgroup)
			effacelisteMesh(heuresSDWSListeMesh, heuresSDWSgroup)
			effacelisteMesh(heuresHPSAListeMesh, heuresHPSAgroup)
			effacelisteMesh(heuresHPWSListeMesh, heuresHPWSgroup)
			effacelisteMesh(arcsDiurnesListeMesh, arcsDiurnesGroup)

		}

		function effacerTouteslesfaces() {
			TouteslesHeuresFalse()
			effacerListesMesh()
			if (lineSommetsFace != undefined) { scene.remove(lineSommetsFace) }
			for (let f = 0; f < nbFaces; f++) {effacerPolyListes(f)}
		}

		function TouteslesHeuresFalse() {
			cs.heuresSolaires = false
			cs.heuresLegalesSummerAutums = false
			cs.heuresLegalesWinterSpring = false
			cs.heuresAntiques = false
			cs.heuresItaliques = false
			cs.heuresSideralesWS = false
			cs.heuresSideralesSA = false
			cs.heuresPlanetairesWS = false
			cs.heuresPlanetairesSA = false
			cs.datesArcsDiurnes = [[]]
			cs.equinoxeAndSolstices = false
			cs.arcsZodiaque = false
		}


		function tracerTouteslesfaces() {
			effacerTouteslesfaces()
			rapellerFace(nfaceActive)
			for (let f = 0; f < nbFaces; f++) {
				nfaceActive = f
				cadran = meshFaces[nfaceActive].clone()
				tracerFaceActive()
				TracerHeuresEtArcs()
			}
			nfaceActive = 0
			tracerFaceActive()
		}

		function tracerTouteslesfacesIdentiques() {

		}


		function rapellerFace(f) {

			TouteslesHeuresFalse()

			cs.heuresSolaires = cs.polyheuresSolaires[f]
			heuresSolairesListeMesh = polyheuresSolairesListeMesh[f]
			heuresSolairesGroup = polyheuresSolairesGroup[f]

			cs.heuresLegalesSummerAutums = cs.polyheuresLegalesSummerAutums[f]
			heuresLegalesListeMeshSA = polyheuresLegalesListeMeshSA[f]
			heuresLegalesGroupSA = polyheuresLegalesGroupSA[f]

			cs.heuresLegalesWinterSpring = cs.polyheuresLegalesWinterSpring[f]
			heuresLegalesListeMeshWS = polyheuresLegalesListeMeshWS[f]
			heuresLegalesGroupWS = polyheuresLegalesGroupWS[f]

			cs.heuresAntiques = cs.polyheuresAntiques[f]
			heuresAntiquesListeMesh = polyheuresAntiquesListeMesh[f]
			heuresAntiquesGroup = polyheuresAntiquesGroup[f]


			cs.heuresBabyloniques = cs.polyheuresBabyloniques[f]
			heuresBabyloniquesListeMesh = polyheuresBabyloniquesListeMesh[f]
			heuresBabyloniquesGroup = polyheuresBabyloniquesGroup[f]

			cs.heuresItaliques = cs.polyheuresItaliques[f]
			heuresItaliquesListeMesh = polyheuresItaliquesListeMesh[f]
			heuresItaliquesGroup = polyheuresItaliquesGroup[f]

			cs.heuresSideralesWS = cs.polyheuresSideralesWS[f]
			heuresSDWSListeMesh = polyheuresSDWSListeMesh[f]
			heuresSDWSgroup = polyheuresSDWSgroup[f]


			cs.heuresSideralesSA = cs.polyheuresSideralesSA[f]
			heuresSDSAListeMesh = polyheuresSDSAListeMesh[f]
			heuresSDSAgroup = polyheuresSDSAgroup[f]

			cs.heuresPlanetairesWS = cs.polyheuresPlanetairesWS[f]
			heuresHPWSListeMesh = polyheuresHPWSListeMesh[f]
			heuresHPWSgroup = polyheuresHPWSgroup[f]

			cs.heuresPlanetairesSA = cs.polyheuresPlanetairesSA[f]
			heuresHPSAListeMesh = polyheuresHPSAListeMesh[f]
			heuresHPSAgroup = polyheuresHPSAgroup[f]

			cs.equinoxeAndSolstices = cs.polyequinoxeAndSolstices[f]
			cs.arcsZodiaque = cs.polyarcsZodiaque[f]
			cs.datesArcsDiurnes = cs.polydatesArcsDiurnes[f]
			arcsDiurnesListeMesh = polyarcsDiurnesListeMesh[f]
			arcsDiurnesGroup = polyarcsDiurnesGroup[f]

			cs.subDivisions = cs.polysubDivisions[f]
		}

		function tracerFaceActive() {
			PlacerStyleToriquePoly(nfaceActive, hauteursGnomons[nfaceActive])
			rapellerFace(nfaceActive)
			cadran = meshFaces[nfaceActive].clone()
			displayFaces(polyhedre)
			TracerHeuresEtArcs()
			VoirPoly2D = false
			cs.deviseSize = cs.polyDevTextsize
			EcrireDevise(cs.polyDev[nfaceActive], cs.polyDevx[nfaceActive], cs.polyDevy[nfaceActive])
			cs.xgnomon = cs.polyGx[nfaceActive]
			cs.ygnomon = cs.polyGy[nfaceActive]
			cs.zgnomon = cs.polyGz[nfaceActive]
			cs.positionDevisex = cs.polyDevx[nfaceActive]
			cs.positionDevisey = cs.polyDevy[nfaceActive]
			cs.devise = cs.polyDev[nfaceActive]
			tracerContourFace(nfaceActive)
			
		}

		function tracerContourFace(aFace) {
					if (lineSommetsFace != undefined) { scene.remove(lineSommetsFace) }
					const sommets = SommetsFace(aFace, polyhedre, false)
					const geometry = new THREE.BufferGeometry().setFromPoints(sommets);
					lineSommetsFace = new THREE.Line(geometry);
					scene.add(lineSommetsFace);
			}
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		function InitGuiPolyedres(gui) {
			

			let rotationFaces = {
				face: 1,

				rotationBase() {
					cs.decli = 0; cs.incli = 90; cs.rot = 0
					PlacerStyleToriquePoly(nfaceActive, hauteursGnomons[nfaceActive])
					displayFaces(polyhedre)
					faceSurBase(nfaceActive)
					tracerTouteslesfaces()
					//SudSundial.show()

				},
				rotationSud() {
					if ((Math.abs(normalsFaces[nfaceActive][0]) > 0.001)) {
						const vSud = new THREE.Vector3(0, 0, 1)
						const vNorm = new THREE.Vector3(normalsFaces[nfaceActive][0], 0, normalsFaces[nfaceActive][2])
						if (normalsFaces[nfaceActive][0] < 0) { cs.decli = cs.decli + vNorm.angleTo(vSud) * 180 / Math.PI }
						if (normalsFaces[nfaceActive][0] > 0) { cs.decli = cs.decli - vNorm.angleTo(vSud) * 180 / Math.PI }
						displayFaces(polyhedre)
						tracerTouteslesfaces()
						//SudSundial.hide()
						// 	cs.decli = 0
						// 	cs.incli = 90
						// 	cs.rot = 0
					}
				}

			}

			guiSectionPoly = gui.addFolder("POLYEDRA");
			if (NouveauCadran) { polyhedre = POLYHEDRA.Dodecahedron; nbFaces = 12 }

			// Choix de la face
			guichoixFace = guiSectionPoly.add(rotationFaces, "face", 1, nbFaces, 1)
				.name(" Edit facet n°")
				.onChange(function (f) {
					aFace = f - 1
					if (aFace >= nbFaces) { aFace = nbFaces - 1 }
					PlacerStyleToriquePoly(aFace, hauteursGnomons[aFace])
					tracerContourFace(aFace)
				})

				.onFinishChange(function (f) {
					nfaceActive = f - 1
					if (nfaceActive >= nbFaces) { nfaceActive = nbFaces - 1 }
					//cs.polydatesArcsDiurnes=[[]]
					rapellerFace(nfaceActive)
					if (cs.uniform) {
						guixgnomon.max(rayonFace[nfaceActive])
						guixgnomon.min(-rayonFace[nfaceActive])
						guixgnomon.updateDisplay()
						guiygnomon.max(rayonFace[nfaceActive])
						guiygnomon.min(-rayonFace[nfaceActive])
						guiygnomon.updateDisplay()
						guixFaceDevise.max(rayonFace[nfaceActive])
						guixFaceDevise.min(-rayonFace[nfaceActive])
						guixFaceDevise.updateDisplay()
						guiyFaceDevise.max(rayonFace[nfaceActive])
						guiyFaceDevise.min(-rayonFace[nfaceActive])
						guiyFaceDevise.updateDisplay()
					}
					
					tracerFaceActive()
					
					garcsZodiaque.updateDisplay();
					gequinoxeAndSolstices.updateDisplay();
					})
				.listen()
			guichoixFace.max(nbFaces)
			guichoixFace.updateDisplay()
			


			//choix de la base et de la face sud

			const gBaseSundial = guiSectionPoly.add(rotationFaces, "rotationBase").name("facet -> base")
			const gSudSundial = guiSectionPoly.add(rotationFaces, "rotationSud").name("facet -> sud")
			//const gtracerUneFace = guiSectionPoly.add(rotationFaces, "tracerUneFace").name("face active")

			// parametrage gnomon

			const folderFaceGnomon = guiSectionPoly.addFolder("gnomon").title("gnomon")

			const guixgnomon = folderFaceGnomon.add(cs, "xgnomon", -1000, 1000, 0.1).name("<- x ->")
				.onChange(function (v) {
					meshGnomons[nfaceActive].add(BoutStyle)
					BoutStyle.position.set(v - cs.polyGx[nfaceActive], cs.polyGz[nfaceActive] / 2, 0)
				})
				.onFinishChange(function (v) { cs.polyGx[nfaceActive] = v; displayFaces(polyhedre); TracerHeuresEtArcs() })
				.listen()
			const guiygnomon = folderFaceGnomon.add(cs, "ygnomon", -500, 500, 0.1).name("<- y ->")
				.onChange(function (v) {
					meshGnomons[nfaceActive].add(BoutStyle)
					BoutStyle.position.set(0, cs.polyGz[nfaceActive] / 2, -v + cs.polyGy[nfaceActive])
				})
				.onFinishChange(function (v) { cs.polyGy[nfaceActive] = v; displayFaces(polyhedre); TracerHeuresEtArcs() })
				.listen()
			folderFaceGnomon.add(cs, "zgnomon", 0, 500, 0.1).name("Heigth")
				.onChange(function (v) {
					meshGnomons[nfaceActive].add(BoutStyle)
					BoutStyle.position.set(0, -cs.polyGz[nfaceActive] / 2 + v, 0)
				})
				.onFinishChange(function (v) { cs.polyGz[nfaceActive] = v; displayFaces(polyhedre); TracerHeuresEtArcs() })
				.listen()

			//thickness
			folderFaceGnomon.add(cs, "egnomon", 0.1, 5, 0.01)
				.name("Thickness")
				.onFinishChange(function () {
					if (RTSpolyhedre()) { displayFaces(polyhedre); tracerTouteslesfaces() }
					TracerHeuresEtArcs()
				});

			//conicité		
			folderFaceGnomon.add(cs, "conicity", 1, 5, 0.1).name("conicity gnomon")
				.onFinishChange(function (v) { displayFaces(polyhedre); TracerHeuresEtArcs() })

			// devise de la face
			const folderFaceDevise = guiSectionPoly.addFolder("motto").title("motto")

			folderFaceDevise.add(cs, "devise").name("text") //.setValue(cs.polyDev[nFace])
				.onChange(function (v) { cs.polyDev[nfaceActive] = v; tracerLaDevise(nfaceActive) })
				.onFinishChange(function (v) { cs.polyDev[nfaceActive] = v; displayFaces(polyhedre) })
				.listen()

			const guixFaceDevise = folderFaceDevise.add(cs, "positionDevisex", -500, 500, 0.1).name("<- x ->")
				.onChange(function (v) { cs.polyDevx[nfaceActive] = v; tracerLaDevise(nfaceActive) })
				.onFinishChange(function (v) { cs.polyDevx[nfaceActive] = v; displayFaces(polyhedre) })
				.listen()

			const guiyFaceDevise = folderFaceDevise.add(cs, "positionDevisey", -500, 500, 0.1).name("<- y ->")
				.onChange(function (v) { cs.polyDevy[nfaceActive] = v; tracerLaDevise(nfaceActive) })
				.onFinishChange(function (v) { cs.polyDevy[nfaceActive] = v; displayFaces(polyhedre) })
				.listen()

			folderFaceDevise.add(cs, 'deviseSize', 0, 5, 0.1).name('font size')
				.onChange(function (v) { cs.polyDevTextsize = v })
				.onFinishChange(function (v) { displayFaces(polyhedre) })

			// choix du polyhedre
			guichoixPoly = guiSectionPoly.addFolder("Choose polyedra")

			categoryFolders = {};
			let parameters = {}// {function(){}};
			// check category[0]. if folder does not exist, create it, add it to that folder.
			// if category field DNE, just add it to the end.
			for (var arg in POLYHEDRA) {
				var guiSection = guichoixPoly
				if (POLYHEDRA[arg].hasOwnProperty("category")) {
					var category = POLYHEDRA[arg].category[0];
					if (!categoryFolders.hasOwnProperty(category))
						categoryFolders[category] = guichoixPoly.addFolder(category);
					guiSection = categoryFolders[category];
				}
				parameters[arg] = function () { };
				const g = guiSection.add(parameters, arg).name(POLYHEDRA[arg].name)
				const a = arg
				g.domElement.addEventListener("click", function () {   // choix du polyhedre
					effacerTouteslesfaces()
					polyhedre = POLYHEDRA[a]
					guiSectionPoly.title("POLYEDRA : " + polyhedre.name)
					cs.typePolyedre = polyhedre.name
					nbFaces = polyhedre.face.length
					NouveauCadran = true
					initFacesPolyedre()
					guichoixFace.max(nbFaces)
					guichoixFace.updateDisplay()
					cs.decli = 0; cs.incli = 90; cs.rot = 0
					cadranSolaireGroup.clear()
					displayFaces(polyhedre)

					faceSurBase(nFaceMax)
					//SudSundial.show()
					nfaceActive = 0
					tracerFaceActive()
					// cadran = meshFaces[nfaceActive].clone()
					// PlacerStyleToriquePoly(nfaceActive,hauteursGnomons[nfaceActive])
				})
			}
			for (var arg in categoryFolders) { categoryFolders[arg].close() }



			//rayon
			guiSectionPoly.add(cs, "rayonPolyedre", 100, 1000, 1).name("radius polyedra")
				.onFinishChange(function (v) {
					cs.uniform = true
					cs.largeur = cs.rayonPolyedre
					cs.hauteur = cs.rayonPolyedre
					cs.epaisseur = cs.rayonPolyedre
					// if (NouveauCadran) {
					// 	if (confirm('Reinit sundial?')) {
					// 		effacerTouteslesfaces()
					// 		initPol()
					// 	}
					// } else {
					effacerTouteslesfaces()
					initPol()
					// }
				})

			//guiSectionPoly.add(cs,"uniform").name("uniform")

			guiSectionPoly.close()
			guichoixPoly.close()




		}  //InitGuiPolyedres

		function voirSectionPoly(b) {

			if (b) {
				guiSectionPoly.show()
				guiSectionPoly.title("POLYEDRA : " + polyhedre.name)
			}
			else { guiSectionPoly.hide() }
		}

		function faceSurBase(n) {
			const vNorm = new THREE.Vector3()
			const eul = new THREE.Euler()
			quaternion.setFromUnitVectors(vNorm.fromArray(normalsFaces[n]), new THREE.Vector3(0, -1, 0))
			eul.setFromQuaternion(quaternion, 'YXZ')
			//cs.decli=eul.y*180/Math.PI
			cs.decli = 0
			cs.incli = eul.x * 180 / Math.PI + 90
			cs.rot = eul.z * 180 / Math.PI
			nFaceBase = n
			displayFaces(polyhedre)
			tracerTouteslesfaces()

		}


		function RTSpolyhedre() {
			if ((cs.typeCadran == RTS) && (cs.typeForme == "polyedric")) { return true } else { return false }
		}

		function initFacesPolyedre() {
			if (NouveauCadran) {
				cs.polyDev = []
				cs.polyGx = []
				cs.polyGy = []
				cs.polyGz = [] // sommet du style droit en coord.locales		
				cs.polyheuresSolaires = []
				cs.polyheuresLegalesSummerAutums = []
				cs.polyheuresLegalesWinterSpring = []
				cs.polyheuresAntiques = []
				cs.polyheuresBabyloniques = []
				cs.polyheuresItaliques = []
				cs.polyheuresSideralesWS = []
				cs.polyheuresSideralesSA = []
				cs.polyheuresPlanetairesWS = []
				cs.polyheuresPlanetairesSA = []
				cs.polyequinoxeAndSolstices = []
				cs.polyarcsZodiaque = []
				cs.polydatesArcsDiurnes = [[]] // [[date, dec en rad]]  tableau à deux dimensions
				cs.polyDevx = []
				cs.polyDevy = []
				cs.polysubDivisions = []

				for (let f = 0; f < nbFaces; f++) {
					let d = "facet " + (f + 1).toString()
					cs.polyDev.push(d)
					cs.polyDevx.push(-10)
					cs.polyDevy.push(10)
					cs.devise = ""
					cs.polydatesArcsDiurnes.push([]) // [[date, dec en rad]]  tableau à deux dimensions}
					cs.polyGx.push(0)
					cs.polyGy.push(0)
					cs.polyGz.push(-1) // sommet du style droit en coord.locales		
					cs.polyheuresSolaires.push(false)
					cs.polyheuresLegalesSummerAutums.push(false)
					cs.polyheuresLegalesWinterSpring.push(false)
					cs.polyheuresAntiques.push(false)
					cs.polyheuresBabyloniques.push(false)
					cs.polyheuresItaliques.push(false)
					cs.polyheuresSideralesWS.push(false)
					cs.polyheuresSideralesSA.push(false)
					cs.polyheuresPlanetairesWS.push(false)
					cs.polyheuresPlanetairesSA.push(false)
					cs.polyequinoxeAndSolstices.push(false)
					cs.polyarcsZodiaque.push(false)
					cs.polysubDivisions.push(1)
				}
				cs.polyheuresSolaires[0] = true

			}//nouveau cadran

			heuresSolairesListeMesh = []
			heuresLegalesListeMeshSA = []
			heuresLegalesListeMeshWS = []
			heuresAntiquesListeMesh = []
			heuresBabyloniquesListeMesh = []
			heuresItaliquesListeMesh = []
			heuresSDSAListeMesh = []
			heuresSDWSListeMesh = []
			heuresHPSAListeMesh = []
			heuresHPWSListeMesh = []
			arcsDiurnesListeMesh = []

			polyheuresSolairesListeMesh = []
			polyheuresLegalesListeMeshSA = []
			polyheuresLegalesListeMeshWS = []
			polyheuresAntiquesListeMesh = []
			polyheuresBabyloniquesListeMesh = []
			polyheuresItaliquesListeMesh = []
			polyheuresSDSAListeMesh = []
			polyheuresSDWSListeMesh = []
			polyheuresHPSAListeMesh = []
			polyheuresHPWSListeMesh = []
			polyarcsDiurnesListeMesh = []

			for (let f = 0; f < nbFaces; f++) {
				polyheuresSolairesListeMesh.push([])
				polyheuresLegalesListeMeshSA.push([])
				polyheuresLegalesListeMeshWS.push([])
				polyheuresAntiquesListeMesh.push([])
				polyheuresBabyloniquesListeMesh.push([])
				polyheuresItaliquesListeMesh.push([])
				polyheuresSDSAListeMesh.push([])
				polyheuresSDWSListeMesh.push([])
				polyheuresHPSAListeMesh.push([])
				polyheuresHPWSListeMesh.push([])
				polyarcsDiurnesListeMesh.push([])
			}

			for (let f = 0; f < nbFaces; f++) {
				polyheuresSolairesGroup.push(new THREE.Group())
				polyheuresLegalesGroupSA.push(new THREE.Group())
				polyheuresLegalesGroupWS.push(new THREE.Group())
				polyheuresAntiquesGroup.push(new THREE.Group())
				polyheuresBabyloniquesGroup.push(new THREE.Group())
				polyheuresItaliquesGroup.push(new THREE.Group())
				polyheuresSDSAgroup.push(new THREE.Group())
				polyheuresSDWSgroup.push(new THREE.Group())
				polyheuresHPSAgroup.push(new THREE.Group())
				polyheuresHPWSgroup.push(new THREE.Group())
				polyarcsDiurnesGroup.push(new THREE.Group())
				// meshGeometry[f]=undefined
				// console.log(meshGeometry[f]==undefined)
			}
			TouteslesHeuresFalse()
			heuresGroupsRemove()

		}


		function initPol() {
			heuresGroupsRemove()
			scene.remove(cadranSolaireGroup)
			cadranSolaireGroup.clear
			cadranSolaireGroup = new THREE.Group()
			scene.add(cadranSolaireGroup)
			initFacesPolyedre()
			voirSectionPoly(true)
			nbFaces = polyhedre.face.length
			guichoixFace.max(nbFaces)
			guichoixFace.updateDisplay()
			cadranSolaireGroup.add(groupAxes)

			Rpol = cs.rayonPolyedre
			Lmax = 3 * Math.max(cs.largeur, cs.hauteur, cs.epaisseur)
			cs.xgnomon = 0; cs.ygnomon = 0

			nfaceActive = 0

			displayFaces(polyhedre)
			tracerTouteslesfaces()
			rapellerFace(0)
			nfaceActive = 0
			tracerFaceActive()
			PlacerLaTerre()

		}


		

	</script>



</body>

</html>